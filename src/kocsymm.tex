\input cwebmac
\def\mod{\mathop{mod}}


\N{1}{1}Introduction.
The \PB{\&{cubepos}} package provides a rich and fast representation of the
Rubik's cube, with a full set of operations including moves,
multiplication, and inversion.  (Please read that document if you
haven't already, because \PB{\&{kocsymm}} builds on that.)  While \PB{%
\&{cubepos}}
is rich and efficient, sometimes it is not exactly what you need.  For
instance, if you wanted to use the \PB{\&{cubepos}} structure to create an
index into an array based on the $12!$ possible permutations of the
edges, you would have to do a fair amount of work.  Other
representations of the cube provide faster indexing operations.  The
two classes defined here, \PB{\&{kocsymm}} and \PB{\&{permcube}}, provide an
alternative representation of the cube that is particularly suitable
for implementations of Herbert Kociemba's two-phase algorithm.

\Y\B\4\X1:\.{kocsymm.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{KOCSYMM\_H}\6
\8\#\&{define} \.{KOCSYMM\_H}\6
\8\#\&{include} \.{"cubepos.h"}\par
\As2, 4, 29, 30\ETs55.\fi

\M{2}The two-phase algorithm is based on the subgroup generated by
$\{U,F2,R2,D,B2,L2\}$.  We refer to this group as $H$.  The idea
behind the two-phase algorithm is to find a way to take an arbitrary
cube position and find a sequence to bring it into the subgroup, and
then solve it within the subgroup using moves within the subgroup.
The first phase is just finding a path within the Schreier coset graph
of the group $H$ to the trivial coset; the second part is solving
within that coset.

The orientation conventions in \PB{\&{cubepos}} were carefully chosen so that
none of the moves that generate $H$ change the orientation of any of
the cubies in the solved position; thus, all positions in $H$, when
represented by \PB{\&{cubepos}}, have the same orientation (both edge and
corners) as the solved position.  Furthermore, none of the moves that
generate $H$ move any of the cubies in the middle slice out of the
middle slice; thus, this is also preserved for all positions in $H$.

It turns out (but we will not prove it here) that every position that
meets these conditions is in the subgroup $H$.  Each of the $8!$
permutations of the corners is reachable, in combination with each of
the $8!$ permutations of the top and bottom edges, and also in
combination with all $4!$ permutations of the middle edges subject
that the overall parity of the corners and edges match.  Thus, the
size of $H$ is $8!\cdot 8!\cdot 4!/2$ or 19,508,428,800.

Given a representative position $p$, the right coset of $H$
corresponding to $p$ is just $Hp$ (where the multiplication operation
of the group is extended to sets in the usual way).  Since all the
positions in $H$ have the same, solved, orientation, this means all
the positions in any particular coset of $H$ (identified by $p$) share
the same orientation.  Similarly, the set of cubie slots that contain
middle edge cubies is also the same for every element of a particular
coset of $H$.  Indeed, these three things, the edge orientation, the
corner orientation, and the cubie slots containing the middle edge
cubies, fully define a coset of $H$.

The \PB{\&{kocsymm}} class contains three integer coordinates that each
represent one of these characteristics, and thus, an entire coset of
$H$.  The \PB{\\{move}} operation on a \PB{\&{kocsymm}} instance is just an
edge on
the coset graph of $H$ induced by the set of move generators we have
chosen.  By using simple integer coordinates, we allow for very fast
operations of \PB{\\{move}} and indexing.  The \PB{\\{csymm}} coordinate
represents
the corner orientation and has $3^7$ possible values; the \PB{\\{eosymm}}
coordinate represents the edge orientation and has $2^{11}$ possible
values; the $epsymm$ coordinate has $12\choose 4$ possible values and
represents the slots that contain the middle four slice cubies.  Where
order matters, we will always give the coordinates in this order.
(They are ordered from largest range to smallest range.)  We define a
type that is large enough for these ranges (and also $8!$,
incidentally) yet still storage efficient, and use this type for most
of our tables.  For the trivial coset, the value of all three
coordinates is chosen to be zero.

\Y\B\4\X1:\.{kocsymm.h }\X${}\mathrel+\E{}$\6
\&{const} \&{int} \.{CORNERSYMM}${}\K\T{2187};{}$\6
\&{const} \&{int} \.{EDGEOSYMM}${}\K\T{2048};{}$\6
\&{const} \&{int} \.{EDGEPERM}${}\K\T{495}{}$;\7
\X18:Constants for \PB{\&{kocsymm}} and \PB{\&{permcube}}\X\7
\&{typedef} \&{unsigned} \&{short} \&{lookup\_type};\6
\&{class} \&{kocsymm} ${}\{{}$\1\6
\4\&{public}:\6
\&{kocsymm}(\,)\1\1\2\2\6
: \\{csymm}(\T{0})${},\39{}$ \\{eosymm}(\T{0})${},\39{}$ \\{epsymm}(\T{0}) ${}%
\{\,\}{}$\7
\&{kocsymm}(\&{int} \|c${},\39{}$\&{int} \\{eo}${},\39{}$\&{int} \\{ep})\1\1\2%
\2\6
: \\{csymm}(\|c)${},\39{}$ \\{eosymm}(\\{eo})${},\39{}$ \\{epsymm}(\\{ep}) ${}%
\{\,\}{}$\7
\X3:Methods for \PB{\&{kocsymm}}\X\6
\X6:Static data declarations for \PB{\&{kocsymm}}\X\7
\&{lookup\_type} \\{csymm}${},{}$ \\{eosymm}${},{}$ \\{epsymm};\2\7
${}\}{}$;\par
\fi

\M{3}We have the same static initialization issue with \PB{\&{kocsymm}} that we
did with \PB{\&{cubepos}}, so we declare a special initializer that forces
an initialization routine to be called, as well as that initialization
routine itself.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\E{}$\6
\&{kocsymm}(\&{int})\1\1\2\2\6
: \\{csymm}(\T{0})${},\39{}$ \\{eosymm}(\T{0})${},\39{}$ \\{epsymm}(\T{0}) ${}%
\{{}$\1\6
\\{init}(\,);\6
\4${}\}{}$\2\7
\&{static} \&{void} \\{init}(\,);\par
\As5, 9, 10, 24, 26\ETs28.
\U2.\fi

\M{4}To force initialization in the proper order for all users of this
include file, we declare a file-static instance here.  Since we
need an identity anyway, we go ahead and make this the identity
object for this class (although there will be multiple instances,
they will all have the same value).

\Y\B\4\X1:\.{kocsymm.h }\X${}\mathrel+\E{}$\6
\&{static} \&{kocsymm} \\{identity\_kc}(\T{1});\par
\fi

\M{5}We use simple ordering, equality, and inequality methods for this
simple value class.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{inline} \&{bool} \&{operator} $<$ (\&{const} \&{kocsymm} ${}{\AND}\\{kc})$ %
\&{const} \6
${}\{{}$\1\6
\&{if} ${}(\\{csymm}\I\\{kc}.\\{csymm}){}$\1\5
\&{return} \\{csymm}${}<\\{kc}.\\{csymm};{}$\2\6
\&{if} ${}(\\{eosymm}\I\\{kc}.\\{eosymm}){}$\1\5
\&{return} \\{eosymm}${}<\\{kc}.\\{eosymm};{}$\2\6
\&{return} \\{epsymm}${}<\\{kc}.\\{epsymm};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{bool} ${}\&{operator}{\E}{}$(\&{const} \&{kocsymm} ${}{\AND}%
\\{kc}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{kc}${}.\\{csymm}\E\\{csymm}\W\\{kc}.\\{eosymm}\E\\{eosymm}\W%
\\{kc}.\\{epsymm}\E\\{epsymm};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{bool} ${}\&{operator}{\I}{}$(\&{const} \&{kocsymm} ${}{\AND}%
\\{kc}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{kc}${}.\\{csymm}\I\\{csymm}\V\\{kc}.\\{eosymm}\I\\{eosymm}\V%
\\{kc}.\\{epsymm}\I\\{epsymm};{}$\6
\4${}\}{}$\2\par
\fi

\M{6}We want to implement a fast move operation, and the range of each
of the coordinates is fairly small, so we use static tables to implement
\PB{\\{move}}.  We choose to use the coordinate value as the first index, as
many of our searches will be depth-first search, and this will give
us some cache locality we would otherwise lose out on.

\Y\B\4\X6:Static data declarations for \PB{\&{kocsymm}}\X${}\E{}$\6
\&{static} \&{lookup\_type} \\{cornermove}[\.{CORNERSYMM}][\.{NMOVES}];\6
\&{static} \&{lookup\_type} \\{edgeomove}[\.{EDGEOSYMM}][\.{NMOVES}];\6
\&{static} \&{lookup\_type} \\{edgepmove}[\.{EDGEPERM}][\.{NMOVES}];\par
\As11\ET20.
\U2.\fi

\M{7}These arrays need to be allocated, so it is time to introduce our
\PB{\\{cpp}} source.

\Y\B\4\X7:\.{kocsymm.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"kocsymm.h"}\6
\8\#\&{include} \.{<iostream>}\6
\&{using} \&{namespace} \&{std};\7
\X8:Static data instantiations\X\6
\X13:Utility methods\X\6
\X15:Method bodies\X\7
\&{void} \&{kocsymm}\DC\\{init}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{int} \\{initialized}${}\K\T{0};{}$\7
\&{if} (\\{initialized})\1\5
\&{return};\2\6
${}\\{initialized}\K\T{1};{}$\6
\X14:Initialize \PB{\&{kocsymm}}\X\6
\&{permcube}\DC\\{init}(\,);\6
\4${}\}{}$\2\par
\fi

\M{8}We need to instantiate these arrays.

\Y\B\4\X8:Static data instantiations\X${}\E{}$\6
\&{lookup\_type} \&{kocsymm}\DC\\{cornermove}[\.{CORNERSYMM}][\.{NMOVES}];\6
\&{lookup\_type} \&{kocsymm}\DC\\{edgeomove}[\.{EDGEOSYMM}][\.{NMOVES}];\6
\&{lookup\_type} \&{kocsymm}\DC\\{edgepmove}[\.{EDGEPERM}][\.{NMOVES}];\par
\As12, 21, 32, 37, 40\ETs44.
\U7.\fi

\M{9}With these arrays, the \PB{\\{move}} operation is very simple.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{void} \\{move}(\&{int} \\{mv})\1\1\2\2\6
${}\{{}$\1\6
${}\\{csymm}\K\\{cornermove}[\\{csymm}][\\{mv}];{}$\6
${}\\{eosymm}\K\\{edgeomove}[\\{eosymm}][\\{mv}];{}$\6
${}\\{epsymm}\K\\{edgepmove}[\\{epsymm}][\\{mv}];{}$\6
\4${}\}{}$\2\par
\fi

\M{10}The easiest way to initialize these arrays are to introduce
conversion routines that allow us to extract the coordinates from a
\PB{\&{cubepos}}, and allow us to set up a \PB{\&{cubepos}} with those
characteristics.  We can use a constructor to go from \PB{\&{cubepos}} to
\PB{\&{kocsymm}}, but we use a \PB{\\{set\_coset}} to modify an existing \PB{%
\&{cubepos}}
so it is in the coset represented by the current \PB{\&{kocsymm}}.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{kocsymm}(\&{const} \&{cubepos} ${}{\AND}\\{cp});{}$\7
\&{void} \\{set\_coset}(\&{cubepos} ${}{\AND}\\{cp}){}$;\par
\fi

\N{1}{11}Numbering the coordinates.
For the corner symmetries, the easiest numbering representation is
just as base-3 number, where the least significant digit comes from
corner 0, and so on, and with the value from corner 7 ignored (since
it must the the negative sum of the other corners).  Similarly, the
edge symmetries are most easily handled as a base-2 number from the
first 11 edges.

The slots holding middle edge cubies is just a bit more complicated.
We insist that the zero value be the solved position.  First we
build a bitmask that always has four bits set; the least significant
four bits represent edge slots 4 to 7 (the middle slots), the
next four bits represent edge slots 8 to 11, and the final four
bits represent edge slots 0 to 3.  We sort all possible 12-bit
values in increasing numerical value, and use the index into this
array to determine the value for \PB{\\{epsymm}}.

To support this, we need two arrays, one to compress the bits from 12
bits down to an \PB{\\{epsymm}} value, and one to expand the \PB{\\{epsymm}}
back
into a bitmask.  The rotations are done in the arrays, so the values
you will obtain from the array and/or pass into the array all have
the bits in normal, 0 though 12, order.

\Y\B\4\X6:Static data declarations for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{static} \&{lookup\_type} ${}\\{epsymm\_compress}[\T{1}\LL\T{12}];{}$\6
\&{static} \&{lookup\_type} \\{epsymm\_expand}[\.{EDGEOSYMM}];\par
\fi

\M{12}The usual instantiation.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{lookup\_type} ${}\&{kocsymm}\DC\\{epsymm\_compress}[\T{1}\LL\T{12}];{}$\6
\&{lookup\_type} \&{kocsymm}\DC\\{epsymm\_expand}[\.{EDGEOSYMM}];\par
\fi

\M{13}To help us fill these arrays, we need a generic bit counting function.
This is not used in any performance-critical code, so we can be a bit
slow.

\Y\B\4\X13:Utility methods\X${}\E{}$\6
\&{static} \&{int} \\{bc}(\&{int} \|v)\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|r${}\K\T{0};{}$\7
\&{while} (\|v)\5
${}\{{}$\1\6
${}\|v\MRL{\AND{\K}}\|v-\T{1};{}$\6
${}\|r\PP;{}$\6
\4${}\}{}$\2\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\A35.
\U7.\fi

\M{14}Filling these two arrays is straightforward.  We also fill the entry
without the high bit set, just in case we decide to only look at 11
cubies rather than 12.

\Y\B\4\X14:Initialize \PB{\&{kocsymm}}\X${}\E{}$\6
\&{int} \|c${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{1}\LL\T{12};{}$ ${}\|i\PP){}$\1\6
\&{if} ${}(\\{bc}(\|i)\E\T{4}){}$\5
${}\{{}$\1\6
\&{int} \\{rotval}${}\K((\|i\LL\T{4})+(\|i\GG\T{8}))\AND\T{\^fff};{}$\7
${}\\{epsymm\_compress}[\\{rotval}]\K\|c;{}$\6
${}\\{epsymm\_compress}[\\{rotval}\AND\T{\^7ff}]\K\|c;{}$\6
${}\\{epsymm\_expand}[\|c]\K\\{rotval};{}$\6
${}\|c\PP;{}$\6
\4${}\}{}$\2\2\par
\As17, 22\ETs23.
\U7.\fi

\M{15}With that done, we are now ready to obtain a \PB{\&{kocsymm}} object from
a
\PB{\&{cubepos}}.  This routine does not have to be dramatically fast.  We
use a little trick; of the edge indices 0 through 11, only those in the
middle edge, with values 4 though 7, have the bit with value 4 set.
Since the cubie numbering for edges has the orientation in the low bit,
this means we actually need to use the bit with value 8.

\Y\B\4\X15:Method bodies\X${}\E{}$\6
\&{kocsymm}\DC\&{kocsymm}(\&{const} \&{cubepos} ${}{\AND}\\{cp}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|c${}\K\T{0},{}$ \\{eo}${}\K\T{0},{}$ \\{ep}${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{6};{}$ ${}\|i\G\T{0};{}$ ${}\|i\MM){}$\1\5
${}\|c\K\T{3}*\|c+\&{cubepos}\DC\\{corner\_ori}(\\{cp}.\|c[\|i]);{}$\2\6
\&{for} (\&{int} \|i${}\K\T{10};{}$ ${}\|i\G\T{0};{}$ ${}\|i\MM){}$\5
${}\{{}$\1\6
${}\\{eo}\K\T{2}*\\{eo}+\&{cubepos}\DC\\{edge\_ori}(\\{cp}.\|e[\|i]);{}$\6
${}\\{ep}\K\T{2}*\\{ep}+(\\{cp}.\|e[\|i]\AND\T{8});{}$\6
\4${}\}{}$\2\6
${}\\{csymm}\K\|c;{}$\6
${}\\{eosymm}\K\\{eo};{}$\6
${}\\{epsymm}\K\\{epsymm\_compress}[\\{ep}\GG\T{3}];{}$\6
\4${}\}{}$\2\par
\As16, 25, 27, 33, 46, 48, 49, 50, 51\ETs52.
\U7.\fi

\M{16}Setting a cubepos to be in the coset is also straightforward.  We
completely destroy the pre-existing permutation in the \PB{\&{cubepos}} as
we do this.  This routine is not particularly fast.  The only
complexity in this routine is recovering the orientation of the
last corner and edge.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{kocsymm}\DC\\{set\_coset}(\&{cubepos} ${}{\AND}\\{cp}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|c${}\K\\{csymm},{}$ \\{eo}${}\K\\{eosymm},{}$ \\{ep}${}\K\\{epsymm%
\_expand}[\\{epsymm}];{}$\6
\&{int} \|s${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{7};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{int} \\{ori}${}\K\|c\MOD\T{3};{}$\7
${}\\{cp}.\|c[\|i]\K\&{cubepos}\DC\\{corner\_val}(\|i,\39\\{ori});{}$\6
${}\|s\MRL{+{\K}}\\{ori};{}$\6
${}\|c\K\|c/\T{3};{}$\6
\4${}\}{}$\2\6
${}\\{cp}.\|c[\T{7}]\K\&{cubepos}\DC\\{corner\_val}(\T{7},\39(\T{8}*\T{3}-\|s)%
\MOD\T{3});{}$\6
${}\|s\K\T{0};{}$\7
\&{int} \\{nextmid}${}\K\T{4};{}$\6
\&{int} \\{nextud}${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{12};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|i\E\T{11}){}$\1\5
${}\\{eo}\K\|s;{}$\2\7
\&{int} \\{ori}${}\K\\{eo}\AND\T{1};{}$\7
\&{if} ${}(\\{ep}\AND\T{1}){}$\1\5
${}\\{cp}.\|e[\|i]\K\&{cubepos}\DC\\{edge\_val}(\\{nextmid}\PP,\39\\{ori});{}$%
\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{cp}.\|e[\|i]\K\&{cubepos}\DC\\{edge\_val}(\\{nextud}\PP,\39\\{ori});{}$\6
\&{if} ${}(\\{nextud}\E\T{4}){}$\1\5
${}\\{nextud}\K\T{8};{}$\2\6
\4${}\}{}$\2\6
${}\|s\MRL{{\XOR}{\K}}\\{ori};{}$\6
${}\\{eo}\MRL{{\GG}{\K}}\T{1};{}$\6
${}\\{ep}\MRL{{\GG}{\K}}\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{17}With these two routines in place, we can fill out our move arrays.
Note that we have to use \PB{\\{movepc}}, since the coset space (which is not
a group) doesn't know where the cubies are, only what the orientations
are in specific slots (and a bit more information about the middle
cubies).

\Y\B\4\X14:Initialize \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{cubepos} \\{cp}${},{}$ \\{cp2};\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{CORNERSYMM};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{kocsymm} ${}\\{kc}(\|i,\39\|i\MOD\.{EDGEOSYMM},\39\|i\MOD\.{EDGEPERM});{}$\7
${}\\{kc}.\\{set\_coset}(\\{cp});{}$\6
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
${}\\{cp2}\K\\{cp};{}$\6
${}\\{cp2}.\\{movepc}(\\{mv});{}$\7
\&{kocsymm} \\{kc2}(\\{cp2});\7
${}\\{cornermove}[\|i][\\{mv}]\K\\{kc2}.\\{csymm};{}$\6
\&{if} ${}(\|i<\.{EDGEOSYMM}){}$\1\5
${}\\{edgeomove}[\|i][\\{mv}]\K\\{kc2}.\\{eosymm};{}$\2\6
\&{if} ${}(\|i<\.{EDGEPERM}){}$\1\5
${}\\{edgepmove}[\|i][\\{mv}]\K\\{kc2}.\\{epsymm};{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\N{1}{18}Symmetry.
Just like \PB{\&{cubepos}}, \PB{\&{kocsymm}} (and later, \PB{\&{permcube}})
have symmetry.
Since these treat the middle layer cubies differently than the others,
some symmetry is broken; we only have 16-way rather than 48-way
symmmetry.  The symmetry of \PB{\&{kocsymm}} and \PB{\&{permcube}} are
specifically
the first 16 symmetries of \PB{\&{cubepos}}, which was carefully constructed
so the middle cubies remain middle cubies.

Calculating corner orientation remapping and middle edge slot
remapping is straightforward, but edge orientation remapping is not so
simple.  Our edge orientation convention as defined by \PB{\&{cubepos}}
treats the front and back faces differently from the left and right
faces, so we cannot simply shuffle the bits around.  However, the
first 8 symmetries of \PB{\&{cubepos}} preserve all three axes, so we can
just shuffle bits for the first eight symmetries.  For the other eight
symmetries, we can use the \PB{\\{epsymm}} information to determine which
cubies are out of the middle slice both before and after rotation, and
exclusive-or that information to correct for this rotation.

In reality, the only thing we use the rotation for is to canonicalize
a \PB{\&{kocsymm}}, so we do not store full remapping information for the
corner symmetry, only enough information for canonicalization.  As
part of this canonicalization we also squeeze and unsqueeze the corner
coordinate (to eliminate gaps created by the canonicalization).  We
define \PB{\.{CORNERRSYMM}} to represent the count of canonical corner
permutations, which we precompute and put here, and then check later
in the initialization routine.

\Y\B\4\X18:Constants for \PB{\&{kocsymm}} and \PB{\&{permcube}}\X${}\E{}$\6
\&{const} \&{int} \.{KOCSYMM}${}\K\T{16};{}$\6
\&{const} \&{int} \.{CORNERRSYMM}${}\K\T{168}{}$;\par
\A19.
\U2.\fi

\M{19}We need a set of arrays to manage the canonicalization.  We need
remapping arrays for the edge orientation and permutation.  We need an
array for the edge permutation that says what bits to flip (but we
only need one entry, used only if we are remapping to 8 through 15).
For corner remapping, we have two cases.  The most common case is
there is a unique remapping that minimizes the corner coordinate, in
which case canonicalization is quick and easy.  The other case is when
there are multiple distinct remappings that all generate the same
minimal corner coordinate.  In this case, we store a bitmask
indicating which remappings to consider, and we must iterate through
them all.

From the corner coordinate, we compute three data items: \PB{\\{minbits}}, a
set of 16 bits, one per symmetry, that generates the minimum corner
coordinate value; \PB{\\{csymm}}, the corner symm we get as a result (after
compaction), and \PB{\\{mimap}}, the minimum mapping that generates that
value.

\Y\B\4\X18:Constants for \PB{\&{kocsymm}} and \PB{\&{permcube}}\X${}\mathrel+%
\E{}$\6
\&{struct} \&{corner\_mapinfo} ${}\{{}$\1\6
\&{unsigned} \&{short} \\{minbits};\6
\&{unsigned} \&{char} \\{csymm}${},{}$ \\{minmap};\2\6
${}\}{}$;\par
\fi

\M{20}We need the following arrays to support canonicalization.

\Y\B\4\X6:Static data declarations for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{static} \&{lookup\_type} \\{cornersymm\_expand}[\.{CORNERRSYMM}];\6
\&{static} \&{corner\_mapinfo} \\{cornersymm}[\.{CORNERSYMM}];\6
\&{static} \&{lookup\_type} \\{edgeomap}[\.{EDGEOSYMM}][\.{KOCSYMM}];\6
\&{static} \&{lookup\_type} \\{edgepmap}[\.{EDGEPERM}][\.{KOCSYMM}];\6
\&{static} \&{lookup\_type} \\{edgepxor}[\.{EDGEPERM}][\T{2}];\par
\fi

\M{21}We need to instantiate those arrays.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{lookup\_type} \&{kocsymm}\DC\\{cornersymm\_expand}[\.{CORNERRSYMM}];\6
\&{corner\_mapinfo} \&{kocsymm}\DC\\{cornersymm}[\.{CORNERSYMM}];\6
\&{lookup\_type} \&{kocsymm}\DC\\{edgeomap}[\.{EDGEOSYMM}][\.{KOCSYMM}];\6
\&{lookup\_type} \&{kocsymm}\DC\\{edgepmap}[\.{EDGEPERM}][\.{KOCSYMM}];\6
\&{lookup\_type} \&{kocsymm}\DC\\{edgepxor}[\.{EDGEPERM}][\T{2}];\par
\fi

\M{22}Our strategy for initializing these is very similar to what we did
for moves: use the \PB{\&{cubepos}} class and the two conversion routines to
do the heavy lifting.  We start by figuring out the corner
compaction values.

\Y\B\4\X14:Initialize \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
$\|c\K\T{0};{}$\6
\&{for} (\&{int} \\{cs}${}\K\T{0};{}$ ${}\\{cs}<\.{CORNERSYMM};{}$ ${}\\{cs}%
\PP){}$\5
${}\{{}$\1\6
\&{int} \\{minval}${}\K\\{cs};{}$\6
\&{int} \\{lowm}${}\K\T{0};{}$\6
\&{int} \\{lowbits}${}\K\T{1};{}$\6
\&{kocsymm} ${}\\{kc}(\\{cs},\39\T{0},\39\T{0});{}$\7
\&{for} (\&{int} \|m${}\K\T{1};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{set\_coset}(\\{cp});{}$\6
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{kocsymm} \\{kc2}(\\{cp2});\7
\&{if} ${}(\\{kc2}.\\{csymm}<\\{minval}){}$\5
${}\{{}$\1\6
${}\\{minval}\K\\{kc2}.\\{csymm};{}$\6
${}\\{lowbits}\K\T{1}\LL\|m;{}$\6
${}\\{lowm}\K\|m;{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{kc2}.\\{csymm}\E\\{minval}){}$\5
${}\{{}$\1\6
${}\\{lowbits}\MRL{{\OR}{\K}}\T{1}\LL\|m;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{minval}\E\\{cs}){}$\5
${}\{{}$\1\6
${}\\{cornersymm\_expand}[\|c]\K\\{minval};{}$\6
${}\\{cornersymm}[\\{cs}].\\{csymm}\K\|c\PP;{}$\6
\4${}\}{}$\2\6
${}\\{cornersymm}[\\{cs}].\\{minbits}\K\\{lowbits};{}$\6
${}\\{cornersymm}[\\{cs}].\\{minmap}\K\\{lowm};{}$\6
${}\\{cornersymm}[\\{cs}].\\{csymm}\K\\{cornersymm}[\\{minval}].\\{csymm};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\|c\I\.{CORNERRSYMM}){}$\1\6
\&{error} (\.{"!\ bad\ cornersym\ res}\)\.{ult"})\1\5
;\2\2\par
\fi

\M{23}Now we compute the edge permutation remapping, the xor values for
the edge permutation, and the edge orientation remapping.  Note that
mapping 8 is self-inverse, so we reverse the result and input so
we can apply the correction to \PB{\\{eosymm}} before the array index.

\Y\B\4\X14:Initialize \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{for} (\&{int} \\{ep}${}\K\T{0};{}$ ${}\\{ep}<\.{EDGEPERM};{}$ ${}\\{ep}%
\PP){}$\5
${}\{{}$\1\6
\&{kocsymm} ${}\\{kc}(\T{0},\39\T{0},\39\\{ep});{}$\7
\&{for} (\&{int} \|m${}\K\T{0};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{set\_coset}(\\{cp});{}$\6
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{kocsymm} \\{kc2}(\\{cp2});\7
${}\\{edgepmap}[\\{ep}][\|m]\K\\{kc2}.\\{epsymm};{}$\6
\&{if} ${}(\|m\E\T{8}){}$\5
${}\{{}$\1\6
${}\\{edgepxor}[\\{kc2}.\\{epsymm}][\T{0}]\K\T{0};{}$\6
${}\\{edgepxor}[\\{kc2}.\\{epsymm}][\T{1}]\K\\{kc2}.\\{eosymm};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{for} (\&{int} \\{eo}${}\K\T{0};{}$ ${}\\{eo}<\.{EDGEOSYMM};{}$ ${}\\{eo}%
\PP){}$\5
${}\{{}$\1\6
\&{kocsymm} ${}\\{kc}(\T{0},\39\\{eo},\39\T{0});{}$\7
\&{for} (\&{int} \|m${}\K\T{0};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{set\_coset}(\\{cp});{}$\6
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{kocsymm} \\{kc2}(\\{cp2});\7
${}\\{edgeomap}[\\{eo}][\|m]\K\\{kc2}.\\{eosymm};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{24}With these arrays, we are ready to canonicalize.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{void} \\{canon\_into}(\&{kocsymm} ${}{\AND}\\{kc}){}$ \&{const};\par
\fi

\M{25}The implementation first checks if we can do it quickly, and if not,
iterates.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{kocsymm}\DC\\{canon\_into}(\&{kocsymm} ${}{\AND}\\{kc}){}$ %
\&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{corner\_mapinfo} ${}{\AND}\\{cm}\K\\{cornersymm}[\\{csymm}];{}$\7
${}\\{kc}.\\{csymm}\K\\{cornersymm\_expand}[\\{cm}.\\{csymm}];{}$\6
${}\\{kc}.\\{eosymm}\K\\{edgeomap}[\\{edgepxor}[\\{epsymm}][\\{cm}.\\{minmap}%
\GG\T{3}]\XOR\\{eosymm}][\\{cm}.\\{minmap}];{}$\6
${}\\{kc}.\\{epsymm}\K\\{edgepmap}[\\{epsymm}][\\{cm}.\\{minmap}];{}$\6
\&{for} (\&{int} \|m${}\K\\{cm}.\\{minmap}+\T{1};{}$ ${}\\{cm}.\\{minbits}\GG%
\|m;{}$ ${}\|m\PP){}$\1\6
\&{if} ${}((\\{cm}.\\{minbits}\GG\|m)\AND\T{1}){}$\5
${}\{{}$\1\6
\&{int} \\{neo}${}\K\\{edgeomap}[\\{edgepxor}[\\{epsymm}][\|m\GG\T{3}]\XOR%
\\{eosymm}][\|m];{}$\7
\&{if} ${}(\\{neo}>\\{kc}.\\{eosymm}){}$\1\5
\&{continue};\2\7
\&{int} \\{nep}${}\K\\{edgepmap}[\\{epsymm}][\|m];{}$\7
\&{if} ${}(\\{neo}<\\{kc}.\\{eosymm}\V\\{nep}<\\{kc}.\\{epsymm}){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{eosymm}\K\\{neo};{}$\6
${}\\{kc}.\\{epsymm}\K\\{nep};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\fi

\M{26}We need a method that returns how much symmetry this \PB{\&{kocsymm}}
has.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{int} \\{calc\_symm}(\,) \&{const};\par
\fi

\M{27}The implementation is just a slight rewriting of \PB{\\{canon\_into}}.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{int} \&{kocsymm}\DC\\{calc\_symm}(\,) \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|r${}\K\T{1};{}$\6
\&{corner\_mapinfo} ${}{\AND}\\{cm}\K\\{cornersymm}[\\{csymm}];{}$\6
\&{int} \\{teosymm}${}\K\\{edgeomap}[\\{edgepxor}[\\{epsymm}][\\{cm}.\\{minmap}%
\GG\T{3}]\XOR\\{eosymm}][\\{cm}.\\{minmap}];{}$\6
\&{int} \\{tepsymm}${}\K\\{edgepmap}[\\{epsymm}][\\{cm}.\\{minmap}];{}$\7
\&{for} (\&{int} \|m${}\K\\{cm}.\\{minmap}+\T{1};{}$ ${}\\{cm}.\\{minbits}\GG%
\|m;{}$ ${}\|m\PP){}$\1\6
\&{if} ${}(((\\{cm}.\\{minbits}\GG\|m)\AND\T{1})\W\\{edgeomap}[\\{edgepxor}[%
\\{epsymm}][\|m\GG\T{3}]\XOR\\{eosymm}][\|m]\E\\{teosymm}\W\\{edgepmap}[%
\\{epsymm}][\|m]\E\\{tepsymm}){}$\1\5
${}\|r\PP;{}$\2\2\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\fi

\M{28}We need a method that tells us if a move is in the Kociemba
group or not.  We can just determine if a transition from the
default state of \PB{\\{epsymm}} is zero or not.

\Y\B\4\X3:Methods for \PB{\&{kocsymm}}\X${}\mathrel+\E{}$\6
\&{static} \&{inline} \&{int} \\{in\_Kociemba\_group}(\&{int} \\{mv})\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{edgepmove}[\T{0}][\\{mv}]${}\E\T{0};{}$\6
\4${}\}{}$\2\par
\fi

\N{1}{29}Storing permutations with \PB{\&{permcube}}.
With \PB{\&{kocsymm}} working, we can turn our attention to storing those
bits of the state that are not stored in it---the permutation
information.  While \PB{\&{kocsymm}} does store a limited amount of
permutation information (what slots the middle four cubies are in),
\PB{\&{permcube}} stores all of the permutation information.  We design
\PB{\&{permcube}} to enable fast moves and indexing of the resulting
state, with the tradeoff that it is not as rich as \PB{\&{cubepos}};
for instance, we do not define inversion.

We store edge permutation information and corner permutation
information separately.  The \PB{\&{kocsymm}} class already defines the
ability to maintain the position of four cubies at a time (as a
group); we exploit that to maintain the slots for the upper edges and
the lower edges as well.  We store this information in the three
fields \PB{\\{et}}, \PB{\\{em}}, and \PB{\\{eb}} (edge top, edge middle, and
edge bottom).
For all three groups of four cubies, we store in addition the order
that the cubies occur within that group of four; we store this in the
fields \PB{\\{etp}}, \PB{\\{emp}}, and \PB{\\{ebp}}.  The information in \PB{%
\\{et}}, \PB{\\{em}}, and
\PB{\\{eb}} is redundant; if we know the slots holding either two sets, we
also know the sets holding the other.  Nonetheless, dividing the $12!$
or 479,001,600 possible states into six smaller chunks, three of 495
values and 3 of 24 values, makes our transition tables much smaller,
and we share the same transition tables for the top, middle, and edge.

For the corners, we use a similar approach: we store which four of the
eight slots contain top corner cubies in \PB{\\{c8\_4}}, and separately, we
store the order of the top cubies in \PB{\\{ctp}}, and the order of the
bottom cubies in \PB{\\{cbp}}.

\Y\B\4\X1:\.{kocsymm.h }\X${}\mathrel+\E{}$\6
\&{const} \&{int} \.{FACT4}${}\K\T{24};{}$\6
\&{const} \&{int} \.{C8\_4}${}\K\T{70};{}$\6
\&{class} \&{permcube} ${}\{{}$\1\6
\4\&{public}:\6
\&{permcube}(\,);\6
\X42:Methods for \PB{\&{permcube}}\X\7
\&{static} \&{void} \\{init}(\,);\7
\X31:Static data declarations for \PB{\&{permcube}}\X\7
\&{unsigned} \&{short} \\{et}${},{}$ \\{em}${},{}$ \\{eb};\6
\&{unsigned} \&{char} \\{etp}${},{}$ \\{emp}${},{}$ \\{ebp};\6
\&{unsigned} \&{char} \\{c8\_4}${},{}$ \\{ctp}${},{}$ \\{cbp};\2\6
${}\}{}$;\par
\fi

\M{30}We allocate a file-scope identity instance statically.  We don't
actually need this one to work around the static initialization
fiasco, but it's always good to have a cheap identity object.

\Y\B\4\X1:\.{kocsymm.h }\X${}\mathrel+\E{}$\6
\&{static} \&{permcube} \\{identity\_pc};\par
\fi

\M{31}To manage all the permutations of four elements, we need to build
the multiplication and inversion table for this group, called $S_4$.
We also declare two arrays, one which takes an eight-byte value, two
bits per element, that gives the permutation (the identity element
would be \PB{\T{0}\\{b11100100}} or \PB{\T{\^e4}}; the least significant bits
represent
the first element) and gives the corresponding index for that
permutation, and one that does the inverse of that.

\Y\B\4\X31:Static data declarations for \PB{\&{permcube}}\X${}\E{}$\6
\&{static} \&{unsigned} \&{char} \\{s4inv}[\.{FACT4}];\6
\&{static} \&{unsigned} \&{char} \\{s4mul}[\.{FACT4}][\.{FACT4}];\6
\&{static} \&{unsigned} \&{char} \\{s4compress}[\T{256}];\6
\&{static} \&{unsigned} \&{char} \\{s4expand}[\.{FACT4}];\par
\As36, 39\ETs43.
\U29.\fi

\M{32}Next, we declare these.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{unsigned} \&{char} \&{permcube}\DC\\{s4inv}[\.{FACT4}];\6
\&{unsigned} \&{char} \&{permcube}\DC\\{s4mul}[\.{FACT4}][\.{FACT4}];\6
\&{unsigned} \&{char} \&{permcube}\DC\\{s4compress}[\T{256}];\6
\&{unsigned} \&{char} \&{permcube}\DC\\{s4expand}[\.{FACT4}];\par
\fi

\M{33}We need an initialization routine for \PB{\&{permcube}}.  This is called
automatically by \PB{\&{kocsymm}\DC\\{init}(\,)} so we don't need a static
initialization hack.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{init}(\,)\1\1\2\2\6
${}\{{}$\1\6
\X34:Initialize \PB{\&{permcube}}\X;\6
\4${}\}{}$\2\par
\fi

\M{34}Permutation numbering.
Normally we would number $S_4$ is lexicographical order.  But for
various reasons we need to compute the parity of the permutation
quickly, so we use bit 0 of the indexing for that purpose; this avoids
a table lookup.

We have another
requirement, however, introduced by \PB{\\{hcoset}}.  Let $i(p)$ be the
integer index assigned to permutation $p$, $p(i)$ to be the
permutation associated with integer index $i$, and $a\cdot b$ to be
the multiplication of the permutation $a$ by the permutation $b$,
and $j\oplus k$ to be the bit-wise exclusive-or of $j$ and $k$.
We want $p(i(a)\oplus 1)\cdot b=p(i(a\cdot b)\oplus 1)$.  Essentially,
we want to group our permutations into pairs, the first even and
the second odd, such that right multiplication preserves the pairs.
We need this so we can collect certain pairs of permutations into
a 24-bit word, perform an operation on them, and be assured that
the result will still fall into a single 24-bit word, rather than
different halves of two different 24-bit words.

It turns out both of these are easy to arrange.  We generate the
permutations in lexicographical order, but use the inverse
permutation rather than the forward permutation, and store the
parity.  For the \PB{\|c} loop below, there are only two values left
for \PB{\|c} and \PB{\|d}, so the two permutations generated in sequence
will have these values swapped, which is precisely what we
need.  The parity is just the exclusive or of the least significant
two bits of the lexicographical order index.

\Y\B\4\X34:Initialize \PB{\&{permcube}}\X${}\E{}$\6
\&{int} \\{cc}${}\K\T{0};{}$\7
\&{for} (\&{int} \|a${}\K\T{0};{}$ ${}\|a<\T{4};{}$ ${}\|a\PP){}$\1\6
\&{for} (\&{int} \|b${}\K\T{0};{}$ ${}\|b<\T{4};{}$ ${}\|b\PP){}$\1\6
\&{if} ${}(\|a\I\|b){}$\1\6
\&{for} (\&{int} \|c${}\K\T{0};{}$ ${}\|c<\T{4};{}$ ${}\|c\PP){}$\1\6
\&{if} ${}(\|a\I\|c\W\|b\I\|c){}$\5
${}\{{}$\1\6
\&{int} \|d${}\K\T{0}+\T{1}+\T{2}+\T{3}-\|a-\|b-\|c;{}$\6
\&{int} \\{coor}${}\K\\{cc}\XOR((\\{cc}\GG\T{1})\AND\T{1});{}$\6
\&{int} \\{expanded}${}\K(\T{1}\LL(\T{2}*\|b))+(\T{2}\LL(\T{2}*\|c))+(\T{3}\LL(%
\T{2}*\|d));{}$\7
${}\\{s4compress}[\\{expanded}]\K\\{coor};{}$\6
${}\\{s4expand}[\\{coor}]\K\\{expanded};{}$\6
${}\\{cc}\PP;{}$\6
\4${}\}{}$\2\2\2\2\2\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{FACT4};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\.{FACT4};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
\&{int} \|k${}\K\\{s4compress}[\\{muls4}(\\{s4expand}[\|i],\39\\{s4expand}[%
\|j])];{}$\7
${}\\{s4mul}[\|j][\|i]\K\|k;{}$\6
\&{if} ${}(\|k\E\T{0}){}$\1\5
${}\\{s4inv}[\|i]\K\|j;{}$\2\6
\4${}\}{}$\2\2\par
\As38, 41, 53\ETs54.
\U33.\fi

\M{35}We still need to write the \PB{\\{muls4}} utility routine.  This is
simple
enough that we simply extract the relevant bits inline.

\Y\B\4\X13:Utility methods\X${}\mathrel+\E{}$\6
\&{int} \\{muls4}(\&{int} \|a${},\39{}$\&{int} \|b)\1\1\2\2\6
${}\{{}$\1\6
\&{int} \|r${}\K\T{3}\AND(\|b\GG(\T{2}*(\|a\AND\T{3})));{}$\7
${}\|r\MRL{+{\K}}(\T{3}\AND(\|b\GG(\T{2}*((\|a\GG\T{2})\AND\T{3}))))\LL%
\T{2};{}$\6
${}\|r\MRL{+{\K}}(\T{3}\AND(\|b\GG(\T{2}*((\|a\GG\T{4})\AND\T{3}))))\LL%
\T{4};{}$\6
${}\|r\MRL{+{\K}}(\T{3}\AND(\|b\GG(\T{2}*((\|a\GG\T{6})\AND\T{3}))))\LL%
\T{6};{}$\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\fi

\M{36}For the edge groups of four, we use the same arrays as \PB{\&{kocsymm}};
these have already been defined and initialized.  For the corner
groups, we need to write compaction and move arrays.

\Y\B\4\X31:Static data declarations for \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{static} \&{unsigned} \&{char} \\{c8\_4\_compact}[\T{256}];\6
\&{static} \&{unsigned} \&{char} \\{c8\_4\_expand}[\.{C8\_4}];\6
\&{static} \&{unsigned} \&{char} \\{c8\_4\_parity}[\.{C8\_4}];\par
\fi

\M{37}Next, we declare these.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{unsigned} \&{char} \&{permcube}\DC\\{c8\_4\_compact}[\T{256}];\6
\&{unsigned} \&{char} \&{permcube}\DC\\{c8\_4\_expand}[\.{C8\_4}];\6
\&{unsigned} \&{char} \&{permcube}\DC\\{c8\_4\_parity}[\.{C8\_4}];\par
\fi

\M{38}To initialize these arrays, we again need to track the parity.  The
pattern is more complex for the eight-bit words that have four bits
set, so we simply count inversions.

\Y\B\4\X34:Initialize \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{int} \|c${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{256};{}$ ${}\|i\PP){}$\1\6
\&{if} ${}(\\{bc}(\|i)\E\T{4}){}$\5
${}\{{}$\1\6
\&{int} \\{parity}${}\K\T{0};{}$\7
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{8};{}$ ${}\|j\PP){}$\1\6
\&{if} ${}(\T{1}\AND(\|i\GG\|j)){}$\1\6
\&{for} (\&{int} \|k${}\K\T{0};{}$ ${}\|k<\|j;{}$ ${}\|k\PP){}$\1\6
\&{if} ${}(\T{0}\E(\T{1}\AND(\|i\GG\|k))){}$\1\5
${}\\{parity}\PP;{}$\2\2\2\2\6
${}\\{c8\_4\_parity}[\|c]\K\\{parity}\AND\T{1};{}$\6
${}\\{c8\_4\_compact}[\|i]\K\|c;{}$\6
${}\\{c8\_4\_expand}[\|c]\K\|i;{}$\6
${}\|c\PP;{}$\6
\4${}\}{}$\2\2\par
\fi

\M{39}The usual use for \PB{\&{permcube}} is to handle operations within the
Kociemba group $H$, where the middle edge positions are always in the
middle edge.  Thus, the group information for the top edges is just
$8\choose 4$ rather than $12\choose 4$, so we need an array to
compress the $12\choose 4$ index (which ranges from 0 to 494) to a
$8\choose 4$ index.

\Y\B\4\X31:Static data declarations for \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{static} \&{unsigned} \&{char} \\{c12\_8}[\.{EDGEPERM}];\6
\&{static} \&{lookup\_type} \\{c8\_12}[\.{C8\_4}];\par
\fi

\M{40}Next, we declare these.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{unsigned} \&{char} \&{permcube}\DC\\{c12\_8}[\.{EDGEPERM}];\6
\&{lookup\_type} \&{permcube}\DC\\{c8\_12}[\.{C8\_4}];\par
\fi

\M{41}Initializing this is straightforward; we expand the bits,
remove the middle four, and compress them again.

\Y\B\4\X34:Initialize \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{EDGEPERM};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{int} \\{expbits}${}\K\&{kocsymm}\DC\\{epsymm\_expand}[\|i];{}$\7
\&{if} ${}(\\{expbits}\AND\T{\^0f0}){}$\1\5
${}\\{c12\_8}[\|i]\K\T{255};{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{int} \\{ii}${}\K\\{c8\_4\_compact}[(\\{expbits}\GG\T{4})+(\\{expbits}\AND%
\T{15})];{}$\7
${}\\{c12\_8}[\|i]\K\\{ii};{}$\6
${}\\{c8\_12}[\\{ii}]\K\|i;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{42}We need equality and ordering routines.  These are a bit long
because of the count of fields.  Note that we cannot use \PB{\\{memcmp}}
reliably because there might be indeterminate padding.

\Y\B\4\X42:Methods for \PB{\&{permcube}}\X${}\E{}$\6
\&{inline} \&{bool} \&{operator} $<$ (\&{const} \&{permcube} ${}{\AND}\\{pc})$ %
\&{const} \6
${}\{{}$\1\6
\&{if} ${}(\\{et}\I\\{pc}.\\{et}){}$\1\5
\&{return} \\{et}${}<\\{pc}.\\{et};{}$\2\6
\&{if} ${}(\\{em}\I\\{pc}.\\{em}){}$\1\5
\&{return} \\{em}${}<\\{pc}.\\{em};{}$\2\6
\&{if} ${}(\\{eb}\I\\{pc}.\\{eb}){}$\1\5
\&{return} \\{eb}${}<\\{pc}.\\{eb};{}$\2\6
\&{if} ${}(\\{etp}\I\\{pc}.\\{etp}){}$\1\5
\&{return} \\{etp}${}<\\{pc}.\\{etp};{}$\2\6
\&{if} ${}(\\{emp}\I\\{pc}.\\{emp}){}$\1\5
\&{return} \\{emp}${}<\\{pc}.\\{emp};{}$\2\6
\&{if} ${}(\\{ebp}\I\\{pc}.\\{ebp}){}$\1\5
\&{return} \\{ebp}${}<\\{pc}.\\{ebp};{}$\2\6
\&{if} ${}(\\{c8\_4}\I\\{pc}.\\{c8\_4}){}$\1\5
\&{return} \\{c8\_4}${}<\\{pc}.\\{c8\_4};{}$\2\6
\&{if} ${}(\\{ctp}\I\\{pc}.\\{ctp}){}$\1\5
\&{return} \\{ctp}${}<\\{pc}.\\{ctp};{}$\2\6
\&{return} \\{cbp}${}<\\{pc}.\\{cbp};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{bool} ${}\&{operator}{\E}{}$(\&{const} \&{permcube} ${}{\AND}%
\\{pc}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{et}${}\E\\{pc}.\\{et}\W\\{em}\E\\{pc}.\\{em}\W\\{eb}\E\\{pc}.%
\\{eb}\W\\{etp}\E\\{pc}.\\{etp}\W\\{emp}\E\\{pc}.\\{emp}\W\\{ebp}\E\\{pc}.%
\\{ebp}\W\\{c8\_4}\E\\{pc}.\\{c8\_4}\W\\{ctp}\E\\{pc}.\\{ctp}\W\\{cbp}\E\\{pc}.%
\\{cbp};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{bool} ${}\&{operator}{\I}{}$(\&{const} \&{permcube} ${}{\AND}%
\\{pc}){}$ \&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{return} \\{et}${}\I\\{pc}.\\{et}\V\\{em}\I\\{pc}.\\{em}\V\\{eb}\I\\{pc}.%
\\{eb}\V\\{etp}\I\\{pc}.\\{etp}\V\\{emp}\I\\{pc}.\\{emp}\V\\{ebp}\I\\{pc}.%
\\{ebp}\V\\{c8\_4}\I\\{pc}.\\{c8\_4}\V\\{ctp}\I\\{pc}.\\{ctp}\V\\{cbp}\I\\{pc}.%
\\{cbp};{}$\6
\4${}\}{}$\2\par
\As45\ET47.
\U29.\fi

\M{43}To write our move method, we need arrays that give the action of
moves on our various fields.  For the edge group
movement, the \PB{\&{kocsymm}} class already provides this information, but
it does not provide information on how the permutation of the
constituent cubies changes.  We need a move array that provides
both pieces of information.  The new coordinate requires nine bits to
represent, and the $S_4$ index requires five bits to represent.  We
could use a three byte struct that would blow up to four bytes total
for alignment, or we can use bit fields.  We prefer bit fields; we
code our own to make sure they fit in a short.  We also need an array
to manage the corner moves, with the same basic structure.  We use
file statics for these; no need to expose them.

\Y\B\4\X31:Static data declarations for \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{static} \&{unsigned} \&{short} \\{eperm\_move}[\.{EDGEPERM}][\.{NMOVES}];\6
\&{static} \&{int} \\{cperm\_move}[\.{C8\_4}][\.{NMOVES}];\par
\fi

\M{44}We instantiate those arrays here.

\Y\B\4\X8:Static data instantiations\X${}\mathrel+\E{}$\6
\&{unsigned} \&{short} \&{permcube}\DC\\{eperm\_move}[\.{EDGEPERM}][%
\.{NMOVES}];\6
\&{int} \&{permcube}\DC\\{cperm\_move}[\.{C8\_4}][\.{NMOVES}];\par
\fi

\M{45}The move routine is declared here.

\Y\B\4\X42:Methods for \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{void} \\{move}(\&{int} \\{mv});\par
\fi

\M{46}The move routine is pretty simple; for each group field, we calculate
its new value, and extract the appropriate $S_4$ effect on the permutation
of its elements from the low order five bits.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{move}(\&{int} \\{mv})\1\1\2\2\6
${}\{{}$\6
\8\#\&{ifdef} \.{SAFETY\_CHECKS}\1\6
\&{if} ${}((\&{kocsymm}\DC\\{epsymm\_expand}[\\{et}]\OR\&{kocsymm}\DC\\{epsymm%
\_expand}[\\{em}]\OR\&{kocsymm}\DC\\{epsymm\_expand}[\\{eb}])\I\T{\^fff}){}$\1\6
\&{error} (\.{"!\ bad\ pc\ in\ move"})\1\5
;\2\2\6
\8\#\&{endif}\7
\&{int} \|t${}\K\\{eperm\_move}[\\{et}][\\{mv}];{}$\7
${}\\{et}\K\|t\GG\T{5};{}$\6
${}\\{etp}\K\\{s4mul}[\\{etp}][\|t\AND\T{31}];{}$\6
${}\|t\K\\{eperm\_move}[\\{em}][\\{mv}];{}$\6
${}\\{em}\K\|t\GG\T{5};{}$\6
${}\\{emp}\K\\{s4mul}[\\{emp}][\|t\AND\T{31}];{}$\6
${}\|t\K\\{eperm\_move}[\\{eb}][\\{mv}];{}$\6
${}\\{eb}\K\|t\GG\T{5};{}$\6
${}\\{ebp}\K\\{s4mul}[\\{ebp}][\|t\AND\T{31}];{}$\6
${}\|t\K\\{cperm\_move}[\\{c8\_4}][\\{mv}];{}$\6
${}\\{c8\_4}\K\|t\GG\T{10};{}$\6
${}\\{ctp}\K\\{s4mul}[\\{ctp}][(\|t\GG\T{5})\AND\T{31}];{}$\6
${}\\{cbp}\K\\{s4mul}[\\{cbp}][\|t\AND\T{31}];{}$\6
\4${}\}{}$\2\par
\fi

\M{47}In order to fill in these arrays, it's easiest to have a pair of
routines that gets a permutation from a \PB{\&{cubepos}}, and another that
sets a permutation from a \PB{\&{cubepos}}.  Unlike \PB{\&{kocsymm}\DC\\{set%
\_coset}}, the
\PB{\\{set\_perm}} routine will preserve the orientation, only affecting the
cubie permutations.  So if you call both \PB{\\{set\_coset}} and \PB{\\{set%
\_perm}},
make sure to call \PB{\\{set\_coset}} first and \PB{\\{set\_perm}} second.

We also provide routines to get only the corner information and
only the edge information because sometimes that's all we need,
and these routines can make a major difference in performance.
We also provide a routine that gets just the up/down permutation
and another that gets just the middle permutation for those
specific cases where the position is guaranteed to be already
in the Kociemba group.  Similar routines exist for setting
just the edge information and setting just the corner information.

\Y\B\4\X42:Methods for \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{void} \\{init\_edge\_from\_cp}(\&{const} \&{cubepos} ${}{\AND}\\{cp});{}$\6
\&{void} \\{init\_corner\_from\_cp}(\&{const} \&{cubepos} ${}{\AND}\\{cp});{}$\7
\&{permcube}(\&{const} \&{cubepos} ${}{\AND}\\{cp});{}$\7
\&{void} \\{set\_edge\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ \&{const};\6
\&{void} \\{set\_corner\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ \&{const};\6
\&{void} \\{set\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ \&{const};\par
\fi

\M{48}The constructor from a basic cube simply iterates through the
cubies, keeping track of which groups each cubie belongs to and
the order that the cubies are seen in.  We iterate backwards so
the least significant cubie ends up in the low order bits.  Edges
first.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{init\_edge\_from\_cp}(\&{const} \&{cubepos} ${}{%
\AND}\\{cp}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{et}\K\\{em}\K\\{eb}\K\T{0};{}$\6
${}\\{etp}\K\\{emp}\K\\{ebp}\K\T{0};{}$\6
\&{for} (\&{int} \|i${}\K\T{11};{}$ ${}\|i\G\T{0};{}$ ${}\|i\MM){}$\5
${}\{{}$\1\6
\&{int} \\{perm}${}\K\&{cubepos}\DC\\{edge\_perm}(\\{cp}.\|e[\|i]);{}$\7
\&{if} ${}(\\{perm}\AND\T{4}){}$\5
${}\{{}$\SHC{ middle layer }\1\6
${}\\{em}\MRL{{\OR}{\K}}\T{1}\LL\|i;{}$\6
${}\\{emp}\K\T{4}*\\{emp}+(\\{perm}\AND\T{3});{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{perm}\AND\T{8}){}$\5
${}\{{}$\SHC{ bottom layer }\1\6
${}\\{eb}\MRL{{\OR}{\K}}\T{1}\LL\|i;{}$\6
${}\\{ebp}\K\T{4}*\\{ebp}+(\\{perm}\AND\T{3});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{et}\MRL{{\OR}{\K}}\T{1}\LL\|i;{}$\6
${}\\{etp}\K\T{4}*\\{etp}+(\\{perm}\AND\T{3});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{et}\K\&{kocsymm}\DC\\{epsymm\_compress}[\\{et}];{}$\6
${}\\{em}\K\&{kocsymm}\DC\\{epsymm\_compress}[\\{em}];{}$\6
${}\\{eb}\K\&{kocsymm}\DC\\{epsymm\_compress}[\\{eb}];{}$\6
${}\\{etp}\K\\{s4compress}[\\{etp}];{}$\6
${}\\{emp}\K\\{s4compress}[\\{emp}];{}$\6
${}\\{ebp}\K\\{s4compress}[\\{ebp}];{}$\6
\4${}\}{}$\2\par
\fi

\M{49}Corners next, plus the routine that puts the two together.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{init\_corner\_from\_cp}(\&{const} \&{cubepos} ${}{%
\AND}\\{cp}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{c8\_4}\K\T{0};{}$\6
${}\\{ctp}\K\\{cbp}\K\T{0};{}$\6
\&{for} (\&{int} \|i${}\K\T{7};{}$ ${}\|i\G\T{0};{}$ ${}\|i\MM){}$\5
${}\{{}$\1\6
\&{int} \\{perm}${}\K\&{cubepos}\DC\\{corner\_perm}(\\{cp}.\|c[\|i]);{}$\7
\&{if} ${}(\\{perm}\AND\T{4}){}$\5
${}\{{}$\SHC{ bottom layer }\1\6
${}\\{cbp}\K\T{4}*\\{cbp}+(\\{perm}\AND\T{3});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{c8\_4}\MRL{{\OR}{\K}}\T{1}\LL\|i;{}$\6
${}\\{ctp}\K\T{4}*\\{ctp}+(\\{perm}\AND\T{3});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{c8\_4}\K\\{c8\_4\_compact}[\\{c8\_4}];{}$\6
${}\\{ctp}\K\\{s4compress}[\\{ctp}];{}$\6
${}\\{cbp}\K\\{s4compress}[\\{cbp}];{}$\6
\4${}\}{}$\2\7
\&{permcube}\DC\&{permcube}(\&{const} \&{cubepos} ${}{\AND}\\{cp}){}$\1\1\2\2\6
${}\{{}$\1\6
\\{init\_edge\_from\_cp}(\\{cp});\6
\\{init\_corner\_from\_cp}(\\{cp});\6
\4${}\}{}$\2\par
\fi

\M{50}The inverse routine is very similar, just in reverse.  Edges
first.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{set\_edge\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ %
\&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{int} \\{et\_bits}${}\K\&{kocsymm}\DC\\{epsymm\_expand}[\\{et}];{}$\6
\&{int} \\{em\_bits}${}\K\&{kocsymm}\DC\\{epsymm\_expand}[\\{em}];{}$\6
\&{int} \\{et\_perm}${}\K\\{s4expand}[\\{etp}];{}$\6
\&{int} \\{em\_perm}${}\K\\{s4expand}[\\{emp}];{}$\6
\&{int} \\{eb\_perm}${}\K\\{s4expand}[\\{ebp}];{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{12};{}$ ${}\|i\PP){}$\1\6
\&{if} ${}((\\{et\_bits}\GG\|i)\AND\T{1}){}$\5
${}\{{}$\SHC{ top layer }\1\6
${}\\{cp}.\|e[\|i]\K\&{cubepos}\DC\\{edge\_val}((\T{3}\AND\\{et\_perm}),\39%
\&{cubepos}\DC\\{edge\_ori}(\\{cp}.\|e[\|i]));{}$\6
${}\\{et\_perm}\MRL{{\GG}{\K}}\T{2};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}((\\{em\_bits}\GG\|i)\AND\T{1}){}$\5
${}\{{}$\SHC{ middle layer }\1\6
${}\\{cp}.\|e[\|i]\K\&{cubepos}\DC\\{edge\_val}((\T{3}\AND\\{em\_perm})+\T{4},%
\39\&{cubepos}\DC\\{edge\_ori}(\\{cp}.\|e[\|i]));{}$\6
${}\\{em\_perm}\MRL{{\GG}{\K}}\T{2};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\SHC{ bottom layer }\1\6
${}\\{cp}.\|e[\|i]\K\&{cubepos}\DC\\{edge\_val}((\T{3}\AND\\{eb\_perm})+\T{8},%
\39\&{cubepos}\DC\\{edge\_ori}(\\{cp}.\|e[\|i]));{}$\6
${}\\{eb\_perm}\MRL{{\GG}{\K}}\T{2};{}$\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\fi

\M{51}Corners next, and we put it together.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{permcube}\DC\\{set\_corner\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ %
\&{const}\1\1\2\2\6
${}\{{}$\1\6
\&{int} \\{c8\_4\_bits}${}\K\\{c8\_4\_expand}[\\{c8\_4}];{}$\6
\&{int} \\{ct\_perm}${}\K\\{s4expand}[\\{ctp}];{}$\6
\&{int} \\{cb\_perm}${}\K\\{s4expand}[\\{cbp}];{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{8};{}$ ${}\|i\PP){}$\1\6
\&{if} ${}((\\{c8\_4\_bits}\GG\|i)\AND\T{1}){}$\5
${}\{{}$\SHC{ top layer }\1\6
${}\\{cp}.\|c[\|i]\K\&{cubepos}\DC\\{corner\_val}((\T{3}\AND\\{ct\_perm}),\39%
\&{cubepos}\DC\\{corner\_ori}(\\{cp}.\|c[\|i]));{}$\6
${}\\{ct\_perm}\MRL{{\GG}{\K}}\T{2};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{cp}.\|c[\|i]\K\&{cubepos}\DC\\{corner\_val}((\T{3}\AND\\{cb\_perm})+%
\T{4},\39\&{cubepos}\DC\\{corner\_ori}(\\{cp}.\|c[\|i]));{}$\6
${}\\{cb\_perm}\MRL{{\GG}{\K}}\T{2};{}$\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\7
\&{void} \&{permcube}\DC\\{set\_perm}(\&{cubepos} ${}{\AND}\\{cp}){}$ \&{const}%
\1\1\2\2\6
${}\{{}$\1\6
\\{set\_edge\_perm}(\\{cp});\6
\\{set\_corner\_perm}(\\{cp});\6
\4${}\}{}$\2\par
\fi

\M{52}Our base constructor is next.  Everything can be set to zero, except
for the \PB{\\{et}} and \PB{\\{eb}} bits, which must be set to values pulled
from
the \PB{\\{epsymm\_expand}} arrays.  Since we are using file static objects
for \PB{\&{kocsymm}} that are defined in every compilation unit, we can assume
that \PB{\&{kocsymm}} and thus \PB{\&{permcube}} is initialized at any point
this
constructor is called.

\Y\B\4\X15:Method bodies\X${}\mathrel+\E{}$\6
\&{permcube}\DC\&{permcube}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{c8\_4}\K\T{0};{}$\6
${}\\{ctp}\K\\{cbp}\K\T{0};{}$\6
${}\\{et}\K\&{kocsymm}\DC\\{epsymm\_compress}[\T{\^f}];{}$\6
${}\\{em}\K\T{0};{}$\6
${}\\{eb}\K\&{kocsymm}\DC\\{epsymm\_compress}[\T{\^f00}];{}$\6
${}\\{etp}\K\\{emp}\K\\{ebp}\K\T{0};{}$\6
\4${}\}{}$\2\par
\fi

\M{53}Now we are prepared to initialize the move arrays.  We need to be
careful to initialize the edge group variables to consistent values.
We do the edges first.

\Y\B\4\X34:Initialize \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{cubepos} \\{cp}${},{}$ \\{cp2};\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{EDGEPERM};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{permcube} \\{pc};\7
${}\\{pc}.\\{em}\K\|i;{}$\7
\&{int} \\{remaining\_edges}${}\K\T{\^fff}-\&{kocsymm}\DC\\{epsymm\_expand}[%
\|i];{}$\6
\&{int} \\{mask}${}\K\T{0};{}$\6
\&{int} \\{bitsseen}${}\K\T{0};{}$\7
\&{while} ${}(\\{bitsseen}<\T{4}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{remaining\_edges}\AND(\\{mask}+\T{1})){}$\1\5
${}\\{bitsseen}\PP;{}$\2\6
${}\\{mask}\K\T{2}*\\{mask}+\T{1};{}$\6
\4${}\}{}$\2\6
${}\\{pc}.\\{et}\K\&{kocsymm}\DC\\{epsymm\_compress}[\\{remaining\_edges}\AND%
\\{mask}];{}$\6
${}\\{pc}.\\{eb}\K\&{kocsymm}\DC\\{epsymm\_compress}[\\{remaining\_edges}\AND%
\CM\\{mask}];{}$\6
${}\\{pc}.\\{set\_perm}(\\{cp});{}$\6
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
${}\\{cp2}\K\\{cp};{}$\6
${}\\{cp2}.\\{movepc}(\\{mv});{}$\7
\&{permcube} \\{pc2}(\\{cp2});\7
${}\\{eperm\_move}[\|i][\\{mv}]\K(\\{pc2}.\\{em}\LL\T{5})+\\{pc2}.\\{emp};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{54}The corner work is even easier; we follow the pattern we have
established.  In this case we need to calculate two permutation
impacts, rather than just one.  At the same time, we compute the edge
up/down values.

\Y\B\4\X34:Initialize \PB{\&{permcube}}\X${}\mathrel+\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\.{C8\_4};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{permcube} \\{pc};\7
${}\\{pc}.\\{c8\_4}\K\|i;{}$\6
${}\\{pc}.\\{set\_perm}(\\{cp});{}$\6
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
${}\\{cp2}\K\\{cp};{}$\6
${}\\{cp2}.\\{movepc}(\\{mv});{}$\7
\&{permcube} \\{pc2}(\\{cp2});\7
${}\\{cperm\_move}[\|i][\\{mv}]\K(\\{pc2}.\\{c8\_4}\LL\T{10})+(\\{pc2}.\\{ctp}%
\LL\T{5})+\\{pc2}.\\{cbp};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{55}We terminate the \PB{\&{kocsymm} $.$ \|h} file here.

\Y\B\4\X1:\.{kocsymm.h }\X${}\mathrel+\E{}$\6
\8\#\&{endif}\par
\fi

\N{1}{56}Testing.  We do some basic unit tests to verify functionality.
First we do some basic tests; do our basic constructors generate
the same thing as the identity cube?

\Y\B\4\X56:Basic tests\X${}\E{}$\6
${}\{{}$\1\6
\&{cubepos} \\{cpi};\6
\&{permcube} \\{pci}(\\{cpi});\6
\&{kocsymm} \\{kci}(\\{cpi});\6
\&{permcube} \\{pct};\6
\&{kocsymm} \\{kct};\7
\&{if} ${}(\\{pct}\I\\{pci}\V\\{kct}\I\\{kci}){}$\1\6
\&{error} (\.{"!\ problem\ with\ defa}\)\.{ult\ constructors"})\1\5
;\2\2\6
\&{if} ${}(\&{permcube}\DC\\{c12\_8}[\\{pc}.\\{et}]\I\T{0}){}$\1\6
\&{error} (\.{"!\ bad\ mapping\ in\ 12}\)\.{->8"})\1\5
;\2\2\6
\4${}\}{}$\2\par
\U62.\fi

\M{57}Next we test conversions.  If we start with a random \PB{\&{cubepos}},
can we convert it to a pair of \PB{\&{kocsymm}} and \PB{\&{permcube}}
structures,
and then back again, with no loss of data?  Also, does the edge
permutation coordinate in the \PB{\&{kocsymm}} match the \PB{\\{em}} field of
the \PB{\&{permcube}} ;

\Y\B\4\X57:Test conversions back and forth\X${}\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{100000};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{cp}.\\{randomize}(\,);{}$\7
\&{kocsymm} \\{kc}(\\{cp});\6
\&{permcube} \\{pc}(\\{cp});\7
\&{if} ${}(\\{kc}.\\{epsymm}\I\\{pc}.\\{em}){}$\1\6
\&{error} (\.{"!\ mismatch\ in\ edge\ }\)\.{middle\ occupancy"})\1\5
;\2\2\6
${}\\{kc}.\\{set\_coset}(\\{cp2});{}$\6
${}\\{pc}.\\{set\_perm}(\\{cp2});{}$\6
\&{if} ${}(\\{cp}\I\\{cp2}){}$\1\6
\&{error} (\.{"!\ mismatch\ in\ conve}\)\.{rsion\ and\ back"})\1\5
;\2\2\6
\4${}\}{}$\2\par
\U62.\fi

\M{58}Next we test the move routines.  Do we get the same results
when we use \PB{\&{permcube}} and \PB{\&{kocsymm}} as we do when we use \PB{%
\&{cubepos}}?

\Y\B\4\X58:Test move routines\X${}\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{1000};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{cp}.\\{randomize}(\,);{}$\7
\&{kocsymm} \\{kc}(\\{cp});\6
\&{permcube} \\{pc}(\\{cp});\6
\&{int} \\{mv}${}\K\\{random\_move\_ext}(\,);{}$\7
${}\\{cp}.\\{movepc}(\\{mv});{}$\6
${}\\{cp2}\K\\{cp};{}$\6
${}\\{kc}.\\{move}(\\{mv});{}$\6
${}\\{pc}.\\{move}(\\{mv});{}$\6
${}\\{kc}.\\{set\_coset}(\\{cp2});{}$\6
${}\\{pc}.\\{set\_perm}(\\{cp2});{}$\6
\&{if} ${}(\\{cp}\I\\{cp2}){}$\1\6
\&{error} (\.{"!\ mismatch\ in\ move\ }\)\.{test"})\1\5
;\2\2\6
\4${}\}{}$\2\par
\U62.\fi

\M{59}The next thing we test is canonicalization in \PB{\&{kocsymm}}.

\Y\B\4\X59:Test canonicalization\X${}\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{1000};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{cp}.\\{randomize}(\,);{}$\7
\&{kocsymm} \\{kc}(\\{cp});\7
\&{for} (\&{int} \|m${}\K\T{1};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{kocsymm} \\{kc2}(\\{cp2});\7
\&{if} ${}(\\{kc2}<\\{kc}){}$\1\5
${}\\{kc}\K\\{kc2};{}$\2\6
\4${}\}{}$\2\7
\&{kocsymm} \\{kc3}(\\{cp});\7
${}\\{kc3}.\\{canon\_into}(\\{kc2});{}$\6
\&{if} ${}(\\{kc2}\I\\{kc}){}$\1\6
\&{error} (\.{"!\ canonicalization\ }\)\.{failuree"})\1\5
;\2\2\6
\4${}\}{}$\2\par
\U62.\fi

\M{60}Finally, we count how many canonical cosets of $H$ there are.
This takes a second or two.

\Y\B\4\X60:Count cosets\X${}\E{}$\6
\&{int} \|s${}\K\T{0};{}$\7
\&{for} (\&{int} \|c${}\K\T{0};{}$ ${}\|c<\.{CORNERSYMM};{}$ ${}\|c\PP){}$\5
${}\{{}$\1\6
\&{int} \\{bits}${}\K\&{kocsymm}\DC\\{cornersymm}[\|c].\\{minbits};{}$\7
\&{if} ${}(\\{bits}\E\T{1}){}$\5
${}\{{}$\1\6
${}\|s\MRL{+{\K}}\.{EDGEOSYMM}*\.{EDGEPERM};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{bits}\AND\T{1}){}$\5
${}\{{}$\1\6
\&{for} (\&{int} \\{eo}${}\K\T{0};{}$ ${}\\{eo}<\.{EDGEOSYMM};{}$ ${}\\{eo}%
\PP){}$\1\6
\&{for} (\&{int} \\{ep}${}\K\T{0};{}$ ${}\\{ep}<\.{EDGEPERM};{}$ ${}\\{ep}%
\PP){}$\5
${}\{{}$\1\6
\&{kocsymm} ${}\\{kc}(\|c,\39\\{eo},\39\\{ep});{}$\7
${}\\{kc}.\\{canon\_into}(\\{kc2});{}$\6
\&{if} ${}(\\{kc}\E\\{kc2}){}$\1\5
${}\|s\PP;{}$\2\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{cout}\LL\.{"Final\ sum\ is\ "}\LL\|s\LL\\{endl};{}$\6
\&{if} ${}(\|s\I\T{138639780}){}$\1\6
\&{error} (\.{"!\ bad\ total\ coset\ c}\)\.{alculation"})\1\5
;\2\2\par
\U62.\fi

\M{61}We do some move timing tests.  We have to make sure to use the results,
or the compiler might eliminate the code.  Note that these timing tests
are for random moves, which may not be indicative of actual performance
in a real program; we only include these timings out of general interest.
In general we expect the \PB{\&{kocsymm}} moves to be fastest, followed by
\PB{\&{permcube}}, and the two routines for \PB{\&{cubepos}} will probably
bring up
the rare.  In any case, we expect any of the move routines to take only a
few dozen nanoseconds.

\Y\B\4\X61:Move timing tests\X${}\E{}$\6
\&{int} \\{mvs}[\T{10000}];\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\5
${}\\{mvs}[\|i]\K\\{random\_move}(\,);{}$\2\6
\\{duration}(\,);\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\1\5
${}\\{kc}.\\{move}(\\{mvs}[\|j]);{}$\2\2\6
${}\\{cout}\LL\.{"Moving\ 100M\ kc\ took}\)\.{\ "}\LL\\{duration}(\,)\LL%
\\{endl};{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\1\5
${}\\{pc}.\\{move}(\\{mvs}[\|j]);{}$\2\2\6
${}\\{cout}\LL\.{"Moving\ 100M\ pc\ took}\)\.{\ "}\LL\\{duration}(\,)\LL%
\\{endl};{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\1\5
${}\\{cp}.\\{move}(\\{mvs}[\|j]);{}$\2\2\6
${}\\{cout}\LL\.{"Moving\ 100M\ cp\ (mov}\)\.{e)\ took\ "}\LL\\{duration}(\,)%
\LL\\{endl};{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\1\5
${}\\{cp}.\\{movepc}(\\{mvs}[\|j]);{}$\2\2\6
${}\\{cout}\LL\.{"Moving\ 100M\ cp\ (mov}\)\.{epc)\ took\ "}\LL\\{duration}(\,)%
\LL\\{endl};{}$\6
\&{if} ${}(\\{cp}<\\{cp2}\W\\{pc}<\\{pc2}\W\\{kc}<\\{kc2}){}$\1\5
${}\\{cout}\LL\.{"(Ignore\ this\ messag}\)\.{e.)"}\LL\\{endl}{}$;\2\par
\U62.\fi

\M{62}We put all the pieces together in our main test routine.

\Y\B\4\X62:\.{kocsymm\_test.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"kocsymm.h"}\6
\8\#\&{include} \.{<iostream>}\6
\&{using} \&{namespace} \&{std};\7
\&{int} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{lrand48}(\,)\E\T{0}){}$\1\5
${}\\{srand48}(\\{getpid}(\,)+\\{time}(\T{0}));{}$\2\7
\&{kocsymm} \\{kc}${},{}$ \\{kc2};\6
\&{permcube} \\{pc}${},{}$ \\{pc2};\6
\&{cubepos} \\{cp}${},{}$ \\{cp2};\7
\X56:Basic tests\X\6
\X57:Test conversions back and forth\X\6
\X58:Test move routines\X\6
\X59:Test canonicalization\X\6
\X60:Count cosets\X\6
\X61:Move timing tests\X\6
\4${}\}{}$\2\par
\fi

\inx
\fin
\con
