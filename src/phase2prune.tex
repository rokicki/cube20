\input cwebmac
\def\mod{\mathop{mod}}


\N{1}{1}Introduction.
Phase two of Kociemba's two-phase algorithm involves finding a
solution to a position in the group $H$ generated by
$\{U,F2,R2,D,B2,L2\}$.  This file constructs a pruning table for
that group.

This group has size $12!\cdot 12!\cdot 4!/2$ or 19,508,428,800 and
distance values from 0 to 18.  If we allocate a byte per entry, we'd
need 20GB of core for the pruning table---this is unreasonably large.

The purpose of this pruning table in the two-phase algorithm is
two-fold.  Remember that during the phase one search, every sequence
found leads to some position $p$ in the $H$ group.  The first use of
the phase two table is to look up an exact or conservative estimate of
the distance remaining to solved, and add that to the length of the
phase one sequence, and see if that sum is less than the length of the
current best solution so far.  If it is not, we can immediately reject
that phase one solution and go on to the next.

If the phase one solution was not rejected, then we need to use the
pruning table to find a phase two solution, completing the overall
solution to the original position.  If the pruning table always has
exact distances, this is guaranteed to succeed.  If the pruning table
only gives conservative approximations of the distance, this may fail.

The phase two solution is found using standard iterated depth-first
search, at each node of the tree looking up the current position in
the pruning table and rejecting that branch of the search if the
distance from the table indicates there is no solution in the given
number of moves.

Our main concern is reducing the size of the table.  The first
technique is to use the 16-way symmetry of $H$ to reduce the table by
only storing a single representative of each symmetry class.  This
reduces the memory requirements from about 20GB down to about 1.2GB;
this is still quite large.

We do not require an exact table, however, so we can hash the state
down into a smaller range.  Remember that all positions in $H$ have a
solved orientation (subject to the conventions we laid out in
\PB{\&{cubepos}}) and the middle four cubies are in the middle four slots.
The group is defined by the permutation of the eight corners, the
permutation of the eight edges whose home position is not in the
middle layer, and the permutation of the four edges whose home
position is the middle layer, subject to the requirement that the
parity of the overall permutation of the edges must match the parity
of the permutation of the corners.

If you hash the state into a smaller range, thus mapping multiple
elements of the group to the same table entry, you must put the
smallest distance of any of the elements that map into that entry,
because the pruning table must give a conservative estimate of the
distance.  For most ways to reduce the size of the table, this gives a
marked reduction in average depth, and thus a marked decrease in the
effectiveness of the table; this is the tradeoff for saving space.  In
this case, however, we can eliminate the permutation of the middle
edges from consideration without significantly decreasing the average
distance; the resulting table is $4!/2$ or 12 times smaller.

The reason this is so is that most optimal sequences that solve a
particular position in $H$ can be transformed into other sequences of
the same length that solve other positions in $H$, but positions that
differ only in the middle edge permutation These other sequences are
not always optimal, but frequently they are.  To understand why this
is so, consider that the moves U1, U2, U3, D1, D2, and D3 do not
affect the middle edges at all.  Indeed, the move U1 is the same as
the move D1 followed by a whole cube rotation clockwise from the top,
if we only consider the top and bottom cubies and ignore the middle
edges and center cubies.  So any sequence that looks like $\alpha U1
\beta$ can be transformed into a different sequence $\alpha D1 \beta'$
that has the same overall effect on the top and bottom edges and
corners (plus a whole cube rotation).  Since a typical solution to a
position in $H$ has many $U$ and $D$ moves that can be so rotated,
there are many distinct sequences that can be directly derived from
the optimal sequence that generate other moves in $H$ that differ only
in whole cube rotations and effect on the middle layer.  There are
only four possible whole cube rotation states if you limit yourself to
rotations around the up-down axis, so even when you limit yourself to
those sequences that end up with the center cubies where you started,
you frequently have many sequences left.

The following table gives the distance distribution both for the group
$H$ and the smaller group $H'$ generated by actions from $H$ on a
representation that omits the middle edges altogether.  You'll note
that the percentages and the average depth is reasonably close.
\vskip\baselineskip
\hbox to \hsize{\hfil\vbox{\halign{\strut\vrule\hfil\quad#
\vrule&\hfil\quad#\space&\hfil\quad#\space\vrule
&\hfil\quad#\space&\hfil\quad#\space\vrule\cr
\noalign{\hrule}
Distance&\multispan2{\hfil$H$\hfil\vrule}&\multispan2{\hfil$H'$\hfil\vrule}\cr
\noalign{\hrule}
0&            1&      &          1&      \cr
1&           10&      &         10&      \cr
2&           67&      &         67&      \cr
3&          456&      &        420&      \cr
4&        3,079&      &      2,335&      \cr
5&       19,948&      &     12,260&      \cr
6&      123,074&      &     61,038&      \cr
7&      736,850&      &    291,004&      \cr
8&    4,185,118&      &  1,327,429& 0.1\%\cr
9&   22,630,733& 0.1\%&  5,821,374& 0.4\%\cr
10&  116,767,872& 0.6\%& 24,141,784& 1.5\%\cr
11&  552,538,680& 2.8\%& 89,480,354& 5.5\%\cr
12&2,176,344,160&11.2\%&262,907,144&16.2\%\cr
13&5,627,785,188&28.8\%&485,409,604&29.9\%\cr
14&7,172,925,794&36.8\%&508,704,668&31.3\%\cr
15&3,608,731,814&18.5\%&232,904,952&14.3\%\cr
16&  224,058,996& 1.1\%& 14,508,468& 0.9\%\cr
17&    1,575,608&      &    129,376&      \cr
18&        1,352&      &        112&      \cr
\noalign{\hrule}
Average&\multispan2{\hfil 13.58\hfil\vrule}&
\multispan2{\hfil 13.29\hfil\vrule}\cr
\noalign{\hrule}
}}\hfil}
\vskip\baselineskip
A 12-fold decrease in table size, with only a 0.29 reduction in
average distance, is remarkable.  The only similar reduction I'm aware
of with Rubik's cube is the reduction from corners-with-centers to
corners-without-centers (the 2x2x2), and the reasoning is similar.

The final improvement we make is to use only four bits for each entry,
which we use to represent values 1 through 16.  A value of zero can be
inferred by inspection, and there are very few positions at 17 or
greater.

This class depends on \PB{\&{cubepos}} and \PB{\&{kocsymm}}, so if you haven't
read those yet, now might be a good time.

\Y\B\4\X1:\.{phase2prune.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PHASE2PRUNE\_H}\6
\8\#\&{define} \.{PHASE2PRUNE\_H}\6
\8\#\&{include} \.{"kocsymm.h"}\par
\A2.\fi

\M{2}We have an initialization routine and a lookup routine.  The
initialization routine is not called at construction time, so you can
declare this class statically but control when it is initialized.
(Initialization may include generation or loading of the pruning
table, which can be a lengthy operation.)  There are no actual
fields or non-static methods; everything in this class is static.

\Y\B\4\X1:\.{phase2prune.h }\X${}\mathrel+\E{}$\6
\&{const} \&{int} \.{FACT8}${}\K\T{40320};{}$\6
\&{class} \&{phase2prune} ${}\{{}$\1\6
\4\&{public}:\6
\&{static} \&{void} \\{init}(\&{int} \\{suppress\_writing}${}\K\T{0});{}$\6
\&{static} \&{int} \\{lookup}(\&{const} \&{cubepos} ${}{\AND}\\{cp});{}$\6
\&{static} \&{int} \\{lookup}(\&{const} \&{permcube} ${}{\AND}\\{pc});{}$\7
\X12:Method declarations\X\6
\X6:Data declarations\X\2\6
${}\};{}$\6
\8\#\&{endif}\par
\fi

\M{3}For the body of the initialization routine, we need to declare
the C++ file at last.  In our initialization routine, we pass
a flag indicating whether or not to suppress the writing of the
pruning table to disk.

\Y\B\4\X3:\.{phase2prune.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"phase2prune.h"}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<cstdio>}\6
\&{using} \&{namespace} \&{std};\7
\X4:Data instantiations\X\6
\X5:Utility methods\X\6
\X11:Method bodies\X\7
\&{void} \&{phase2prune}\DC\\{init}(\&{int} \\{suppress\_writing})\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{int} \\{initialized}${}\K\T{0};{}$\7
\&{if} (\\{initialized})\1\5
\&{return};\2\6
${}\\{initialized}\K\T{1};{}$\6
\X8:Initialize the instance\X\6
\4${}\}{}$\2\par
\fi

\M{4}When we lookup a \PB{\&{cubepos}} in this pruning table, the first thing
to
do is to compute a canonical representative.  We cannot use the normal
\PB{\&{cubepos}} canonicalization, because that takes orientation into
account, and this pruning table must not.  Instead, we use the corner
permutation (as calculated by \PB{\&{permcube}}) to select a canonical
coordinate.  For each corner permutation, we need to store the $m\in
M$ remapping, the reduced corner permutation coordinate, and the set
of bits that give what remappings generate that minimum coordinate.
This is like \PB{\\{corner\_mapinfo}} in \PB{\&{kocsymm}}, except the minimum
coordinate will not fit in an \PB{\&{unsigned} \&{char}}.  This array has size
160K, but this is dwarfed by the actual pruning table itself.

When we generate the pruning table, we will use the corner calculates
as the outer loop (since that's what we are remapping by)
and use the edge permutation as the inner loop.  To make this
reasonably fast, we need a table that can remap an edge
up/down permutation.  This is not a small table, but it's also
dwarfed by the pruning table.

\Y\B\4\X4:Data instantiations\X${}\E{}$\6
\&{struct} \&{corner\_reduce} ${}\{{}$\1\6
\&{unsigned} \&{char} \|m${},{}$ \\{parity};\6
\&{lookup\_type} \|c${},{}$ \\{minbits};\2\6
${}\}{}$ \\{corner\_reduction}[\.{FACT8}];\6
\&{lookup\_type} \\{edgeud\_remap}[\.{KOCSYMM}][\.{FACT8}];\par
\As7\ET18.
\U3.\fi

\M{5}Filling out the corner reduction array is fairly straightforward; we
use the existing classes \PB{\&{cubepos}} and \PB{\&{permcube}} to do the work.
First we need a particular ordering of the corner elements of \PB{%
\&{permcube}};
this is somewhat arbitrary.

\Y\B\4\X5:Utility methods\X${}\E{}$\6
\&{inline} \&{int} \\{corner\_coordinate}(\&{const} \&{permcube} ${}{\AND}%
\\{pc}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\\{pc}.\\{c8\_4}*\.{FACT4}+\\{pc}.\\{ctp})*\.{FACT4}+\\{pc}.%
\\{cbp};{}$\6
\4${}\}{}$\2\7
\&{inline} \&{int} \\{edge\_coordinate}(\&{const} \&{permcube} ${}{\AND}%
\\{pc}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{return} ${}(\&{permcube}\DC\\{c12\_8}[\\{pc}.\\{et}]*\.{FACT4}+\\{pc}.%
\\{etp})*\.{FACT4}+\\{pc}.\\{ebp};{}$\6
\4${}\}{}$\2\par
\A19.
\U3.\fi

\M{6}Once we know how many symmetry-reduced coordinates there are, we also
know how much memory we need.  We declare a variable to hold that value
here, as well as our memory array pointer.

\Y\B\4\X6:Data declarations\X${}\E{}$\6
\&{static} \&{int} \\{cornermax};\6
\&{static} \&{unsigned} \&{int} \\{memsize};\6
\&{static} \&{unsigned} \&{int} ${}{*}\\{mem}{}$;\par
\A17.
\U2.\fi

\M{7}We need to declare all of these instances.

\Y\B\4\X4:Data instantiations\X${}\mathrel+\E{}$\6
\&{int} \&{phase2prune}\DC\\{cornermax};\6
\&{unsigned} \&{int} \&{phase2prune}\DC\\{memsize};\6
\&{unsigned} \&{int} ${}{*}\&{phase2prune}\DC\\{mem}{}$;\par
\fi

\M{8}Now we try all possibilities.

\Y\B\4\X8:Initialize the instance\X${}\E{}$\6
$\\{cornermax}\K\T{0};{}$\6
\&{for} (\&{int} \\{c8\_4}${}\K\T{0};{}$ ${}\\{c8\_4}<\.{C8\_4};{}$ ${}\\{c8%
\_4}\PP){}$\1\6
\&{for} (\&{int} \\{ctp}${}\K\T{0};{}$ ${}\\{ctp}<\.{FACT4};{}$ ${}\\{ctp}%
\PP){}$\1\6
\&{for} (\&{int} \\{cbp}${}\K\T{0};{}$ ${}\\{cbp}<\.{FACT4};{}$ ${}\\{cbp}%
\PP){}$\5
${}\{{}$\1\6
\&{permcube} \\{pc};\7
${}\\{pc}.\\{c8\_4}\K\\{c8\_4};{}$\6
${}\\{pc}.\\{ctp}\K\\{ctp};{}$\6
${}\\{pc}.\\{cbp}\K\\{cbp};{}$\7
\&{int} \\{oc}${}\K\\{corner\_coordinate}(\\{pc});{}$\6
\&{int} \\{minc}${}\K\\{oc};{}$\6
\&{int} \\{minm}${}\K\T{0};{}$\6
\&{int} \\{minbits}${}\K\T{1};{}$\6
\&{cubepos} \\{cp};\7
${}\\{pc}.\\{set\_perm}(\\{cp});{}$\6
\&{for} (\&{int} \|m${}\K\T{1};{}$ ${}\|m<\T{16};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
\&{cubepos} \\{cp2};\7
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{permcube} \\{pc2}(\\{cp2});\6
\&{int} \\{tc}${}\K\\{corner\_coordinate}(\\{pc2});{}$\7
\&{if} ${}(\\{tc}<\\{minc}){}$\5
${}\{{}$\1\6
${}\\{minc}\K\\{tc};{}$\6
${}\\{minm}\K\|m;{}$\6
${}\\{minbits}\K\T{1}\LL\|m;{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{tc}\E\\{minc}){}$\1\5
${}\\{minbits}\MRL{{\OR}{\K}}\T{1}\LL\|m;{}$\2\6
\4${}\}{}$\2\7
\&{corner\_reduce} ${}{\AND}\\{cr}\K\\{corner\_reduction}[\\{oc}];{}$\7
\&{if} ${}(\\{oc}\E\\{minc}){}$\1\5
${}\\{cr}.\|c\K\\{cornermax}\PP;{}$\2\6
${}\\{cr}.\|m\K\\{minm};{}$\6
${}\\{cr}.\|c\K\\{corner\_reduction}[\\{minc}].\|c;{}$\6
${}\\{cr}.\\{minbits}\K\\{minbits};{}$\6
${}\\{cr}.\\{parity}\K(\&{permcube}\DC\\{c8\_4\_parity}[\\{c8\_4}]+\\{ctp}+%
\\{cbp})\AND\T{1};{}$\6
\4${}\}{}$\2\2\2\par
\As9, 10\ETs23.
\U3.\fi

\M{9}Next we initialize the remapping of the edge coordinates.
\Y\B\4\X8:Initialize the instance\X${}\mathrel+\E{}$\6
\&{int} \\{at}${}\K\T{0};{}$\6
\&{cubepos} \\{cp}${},{}$ \\{cp2};\7
\&{for} (\&{int} \\{e8\_4}${}\K\T{0};{}$ ${}\\{e8\_4}<\.{C8\_4};{}$ ${}\\{e8%
\_4}\PP){}$\5
${}\{{}$\1\6
\&{permcube} \\{pc};\7
${}\\{pc}.\\{et}\K\&{permcube}\DC\\{c8\_12}[\\{e8\_4}];{}$\6
${}\\{pc}.\\{eb}\K\&{kocsymm}\DC\\{epsymm\_compress}[\T{\^f0f}-\&{kocsymm}\DC%
\\{epsymm\_expand}[\\{pc}.\\{et}]];{}$\6
\&{for} (\&{int} \\{etp}${}\K\T{0};{}$ ${}\\{etp}<\.{FACT4};{}$ ${}\\{etp}%
\PP){}$\5
${}\{{}$\1\6
${}\\{pc}.\\{etp}\K\\{etp};{}$\6
\&{for} (\&{int} \\{ebp}${}\K\T{0};{}$ ${}\\{ebp}<\.{FACT4};{}$ ${}\\{ebp}\PP,%
\39\\{at}\PP){}$\5
${}\{{}$\1\6
${}\\{pc}.\\{ebp}\K\\{ebp};{}$\6
\&{for} (\&{int} \|m${}\K\T{0};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
${}\\{pc}.\\{set\_edge\_perm}(\\{cp});{}$\6
${}\\{cp}.\\{remap\_into}(\|m,\39\\{cp2});{}$\7
\&{permcube} \\{pc2}(\\{cp2});\7
${}\\{edgeud\_remap}[\|m][\\{at}]\K\\{edge\_coordinate}(\\{pc2});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{10}We continue our initialization with allocation of the memory array.
We store two bytes per entry.

\Y\B\4\X8:Initialize the instance\X${}\mathrel+\E{}$\6
$\\{memsize}\K\\{cornermax}*(\.{FACT8}/\T{2});{}$\6
${}\\{mem}\K{}$(\&{unsigned} \&{int} ${}{*}){}$ \\{malloc}(\\{memsize});\6
\&{if} ${}(\\{mem}\E\T{0}){}$\1\6
\&{error} (\.{"!\ no\ memory\ in\ phas}\)\.{e2prune"})\1\5
;\2\2\par
\fi

\N{1}{11}Looking up a position.
We write our lookup routine
carefully, inlining the portions of the \PB{\\{remap}} and coordinate
calculation code we really need.  Even with this care, this code will
probably encounter numerous cache misses in a single lookup because of
the large tables in use.

\Y\B\4\X11:Method bodies\X${}\E{}$\6
\&{int} \&{phase2prune}\DC\\{lookup}(\&{const} \&{cubepos} ${}{\AND}\\{cp}){}$%
\1\1\2\2\6
${}\{{}$\1\6
\&{permcube} \\{pc}(\\{cp});\7
\&{return} \\{lookup}(\\{pc});\6
\4${}\}{}$\2\7
\&{int} \&{phase2prune}\DC\\{lookup}(\&{const} \&{permcube} ${}{\AND}\\{pc}){}$%
\1\1\2\2\6
${}\{{}$\1\6
\&{int} \\{cc}${}\K\\{corner\_coordinate}(\\{pc});{}$\6
\&{corner\_reduce} ${}{\AND}\\{cr}\K\\{corner\_reduction}[\\{cc}];{}$\6
\&{int} \\{off}${}\K\\{cr}.\|c*\.{FACT8}+\\{edgeud\_remap}[\\{cr}.\|m][\\{edge%
\_coordinate}(\\{pc})];{}$\6
\&{int} \|r${}\K(\\{mem}[\\{off}\GG\T{3}]\GG(\T{4}*(\\{off}\AND\T{7})))\AND\T{%
\^f};{}$\7
\&{if} ${}(\|r\E\T{0}\W\\{pc}\E\\{identity\_pc}){}$\1\5
\&{return} \T{0};\2\6
\&{else}\1\5
\&{return} \|r${}+\T{1};{}$\2\6
\4${}\}{}$\2\par
\As13, 20, 21, 22\ETs25.
\U3.\fi

\N{1}{12}Generating the pruning table.
We need a routine to generate the pruning table.  To do this, we
initialize the solved position to the value \PB{\T{0}} and all other
positions to the value 15.  Then for values of $d$ from 0 to 13, we
find all positions at that depth, compute their neighbors, and if
their neighbors are so far unseen, set the depth to $d+1$.  Since we
share the representations of distances 0 and 1 using the value 0 in
the array, we actually initialize the start with a value of 1, and
after the first iteration, we reset that back to 0.

\Y\B\4\X12:Method declarations\X${}\E{}$\6
\&{static} \&{void} \\{gen\_table}(\,);\6
\&{static} \&{int} \\{read\_table}(\,);\6
\&{static} \&{void} \\{write\_table}(\,);\6
\&{static} \&{void} \\{check\_integrity}(\,);\par
\A24.
\U2.\fi

\M{13}There is one major subtlety when generating pruning tables that depend
on symmetry like this one: we don't want to have to do a full symmetry
reduction on every lookup; we just want to reduce symmetry by the
corner permutation.  The tricky thing then is whenever our destination
corner permutation has any symmetry, we must be sure to compute and
update all relevant symmetry values for that element.

\Y\B\4\X11:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{phase2prune}\DC\\{gen\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{memset}(\\{mem},\39\T{255},\39\\{memsize});{}$\6
${}\\{cout}\LL\.{"Gen\ phase2"}\LL\\{flush};{}$\6
${}\\{mem}[\T{0}]\MRL{\AND{\K}}\CM\T{14};{}$\7
\&{int} \\{seen}${}\K\T{1};{}$\7
\&{for} (\&{int} \|d${}\K\T{0};{}$ ${}\|d<\T{15};{}$ ${}\|d\PP){}$\5
${}\{{}$\1\6
\&{unsigned} \&{int} \\{seek}${}\K(\|d\?\|d-\T{1}:\T{1});{}$\6
\&{int} \\{newval}${}\K\|d;{}$\7
\&{for} (\&{int} \\{c8\_4}${}\K\T{0};{}$ ${}\\{c8\_4}<\.{C8\_4};{}$ ${}\\{c8%
\_4}\PP){}$\1\6
\&{for} (\&{int} \\{ctp}${}\K\T{0};{}$ ${}\\{ctp}<\.{FACT4};{}$ ${}\\{ctp}%
\PP){}$\1\6
\&{for} (\&{int} \\{cbp}${}\K\T{0};{}$ ${}\\{cbp}<\.{FACT4};{}$ ${}\\{cbp}%
\PP){}$\5
${}\{{}$\1\6
\&{permcube} \\{pc};\7
${}\\{pc}.\\{c8\_4}\K\\{c8\_4};{}$\6
${}\\{pc}.\\{ctp}\K\\{ctp};{}$\6
${}\\{pc}.\\{cbp}\K\\{cbp};{}$\7
\&{int} \\{oc}${}\K\\{corner\_coordinate}(\\{pc});{}$\6
\&{corner\_reduce} ${}{\AND}\\{cr}\K\\{corner\_reduction}[\\{oc}];{}$\7
\&{if} ${}(\\{cr}.\\{minbits}\AND\T{1}){}$\5
${}\{{}$\1\6
\X14:Iterate over all moves\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\2\6
\8\#\&{ifndef} \.{QUARTER}\6
\&{if} ${}(\|d\E\T{0}){}$\1\5
${}\\{mem}[\T{0}]\MRL{\AND{\K}}\CM\T{15};{}$\2\6
\8\#\&{endif}\6
${}\\{cout}\LL\.{"\ "}\LL\|d\LL\\{flush};{}$\6
\4${}\}{}$\2\6
${}\\{cout}\LL\.{"\ done."}\LL\\{endl}\LL\\{flush};{}$\6
\4${}\}{}$\2\par
\fi

\M{14}Try all the different moves from this corner position.
Note that we only handle half turn metric at the moment.  In any
case, hoist the destination corner permutation computation to the
top of the loop.  We also calculate offsets from both the
source and the destination rows.

\Y\B\4\X14:Iterate over all moves\X${}\E{}$\6
\&{permcube} \\{pc2}${},{}$ \\{pc3}${},{}$ \\{pc4};\6
\&{cubepos} \\{cp2}${},{}$ \\{cp3};\6
\&{int} \\{off}${}\K\\{corner\_reduction}[\\{oc}].\|c*(\.{FACT8}/\T{8});{}$\7
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
\&{if} ${}(\R\&{kocsymm}\DC\\{in\_Kociemba\_group}(\\{mv})){}$\1\5
\&{continue};\2\6
${}\\{pc2}\K\\{pc};{}$\6
${}\\{pc2}.\\{move}(\\{mv});{}$\7
\&{int} \\{dest\_off}${}\K\\{corner\_coordinate}(\\{pc2});{}$\6
\&{corner\_reduce} ${}{\AND}\\{cr}\K\\{corner\_reduction}[\\{dest\_off}];{}$\6
\&{int} \\{destat}${}\K\\{cr}.\|c*(\.{FACT8}/\T{8});{}$\7
\&{for} (\&{int} \|m${}\K\\{cr}.\|m;{}$ ${}(\T{1}\LL\|m)\Z\\{cr}.%
\\{minbits};{}$ ${}\|m\PP){}$\1\6
\&{if} ${}((\\{cr}.\\{minbits}\GG\|m)\AND\T{1}){}$\5
${}\{\X15:Scan one row\X\}{}$\2\6
\4${}\}{}$\2\par
\U13.\fi

\M{15}When we scan a row, we need to work on the $8!$ possible permutations
of the edge cubies, doing a move and a remapping on each.  For efficiency
we embed parts of the \PB{\&{permcube}} move routine in here.  We accelerate
the scan if we see a bunch of unset values.

\Y\B\4\X15:Scan one row\X${}\E{}$\6
\&{int} \\{at}${}\K\T{0};{}$\7
\&{for} (\&{int} \\{e8\_4}${}\K\T{0};{}$ ${}\\{e8\_4}<\.{C8\_4};{}$ ${}\\{e8%
\_4}\PP){}$\5
${}\{{}$\1\6
\&{int} \\{et}${}\K\&{permcube}\DC\\{c8\_12}[\\{e8\_4}];{}$\6
\&{int} \\{t1}${}\K\&{permcube}\DC\\{eperm\_move}[\\{et}][\\{mv}];{}$\6
\&{int} \\{eb}${}\K\&{kocsymm}\DC\\{epsymm\_compress}[\T{\^f0f}-\&{kocsymm}\DC%
\\{epsymm\_expand}[\\{et}]];{}$\6
\&{int} \\{t2}${}\K\&{permcube}\DC\\{eperm\_move}[\\{eb}][\\{mv}]\AND\T{31};{}$%
\6
\&{int} \\{dst1}${}\K\&{permcube}\DC\\{c12\_8}[\\{t1}\GG\T{5}]*\T{24}*%
\T{24};{}$\7
${}\\{t1}\MRL{\AND{\K}}\T{31};{}$\6
\&{for} (\&{int} \\{etp}${}\K\T{0};{}$ ${}\\{etp}<\.{FACT4};{}$ ${}\\{etp}%
\PP){}$\1\6
\&{for} (\&{int} \\{ebp}${}\K\T{0};{}$ ${}\\{ebp}<\.{FACT4};{}$ ${}\\{ebp}\PP,%
\39\\{at}\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{mem}[\\{off}+(\\{at}\GG\T{3})]\E\T{\^ffffffff}){}$\5
${}\{{}$\1\6
${}\\{ebp}\MRL{+{\K}}\T{7};{}$\6
${}\\{at}\MRL{+{\K}}\T{7};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(((\\{mem}[\\{off}+(\\{at}\GG\T{3})]\GG(\T{4}*(\\{at}\AND%
\T{7})))\AND\T{\^f})\E\\{seek}){}$\5
${}\{\X16:Handle one position\X\}{}$\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\U14.\fi

\M{16}We've found a single position at the distance we seek.  Find all of its
neighbors, and check if this is a newly reached value.

\Y\B\4\X16:Handle one position\X${}\E{}$\6
\&{int} \\{etp1}${}\K\&{permcube}\DC\\{s4mul}[\\{etp}][\\{t1}];{}$\6
\&{int} \\{ebp1}${}\K\&{permcube}\DC\\{s4mul}[\\{ebp}][\\{t2}];{}$\6
\&{int} \\{dat}${}\K\\{edgeud\_remap}[\|m][\\{dst1}+\\{etp1}*\T{24}+%
\\{ebp1}];{}$\6
\&{int} \\{val}${}\K(\\{mem}[\\{destat}+(\\{dat}\GG\T{3})]\GG(\T{4}*(\\{dat}%
\AND\T{7})))\AND\T{\^f};{}$\7
\&{if} ${}(\\{val}\E\T{\^f}){}$\5
${}\{{}$\1\6
${}\\{mem}[\\{destat}+(\\{dat}\GG\T{3})]\MRL{-{\K}}(\T{\^f}-\\{newval})\LL(%
\T{4}*(\\{dat}\AND\T{7}));{}$\6
${}\\{seen}\PP;{}$\6
\4${}\}{}$\2\par
\U15.\fi

\N{1}{17}Disk I/O.
The pruning table takes a fair amount of time to generate (about
40 seconds on modern hardware), and I'm frequently impatient, so we
add some routines to read and write the pruning table to a file on
disk.

\Y\B\4\X6:Data declarations\X${}\mathrel+\E{}$\6
\&{static} \&{const} \&{char} ${}{*\&{const}\ }\\{filename};{}$\6
\&{static} \&{int} \\{file\_checksum};\par
\fi

\M{18}We choose the filename below, to indicate version 1 of the
phase 2 pruning data, halfturn metric.

\Y\B\4\X4:Data instantiations\X${}\mathrel+\E{}$\6
\&{const} \&{char} ${}{*\&{const}\ }\&{phase2prune}\DC\\{filename}\K%
\.{"p2p1h.dat"};{}$\6
\&{int} \&{phase2prune}\DC\\{file\_checksum};\par
\fi

\M{19}We need a routine to do a checksum of the file, to verify integrity.
We use a simplistic hash function.  We make it file static; we might
use a different one in a different file.

\Y\B\4\X5:Utility methods\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{datahash}(\&{unsigned} \&{int} ${}{*}\\{dat},\39{}$%
\&{int} \\{sz}${},\39{}$\&{int} \\{seed})\1\1\2\2\6
${}\{{}$\1\6
\&{while} ${}(\\{sz}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{sz}\MRL{-{\K}}\T{4};{}$\6
${}\\{seed}\K\T{37}*\\{seed}+{*}\\{dat}\PP;{}$\6
\4${}\}{}$\2\6
\&{return} \\{seed};\6
\4${}\}{}$\2\par
\fi

\M{20}Our read routine is straightforward; we return 1 on success, and
0 on failure.  We could read the whole thing at once and then checksum
it afterwards, but we choose to do it in chunks that fit in cache.
The \PB{\.{"rb"}} in the \PB{\\{fopen}} call is to force binary mode on Windows
platforms.

\Y\B\4\X11:Method bodies\X${}\mathrel+\E{}$\6
\&{const} \&{int} \.{CHUNKSIZE}${}\K\T{65536};{}$\7
\&{int} \&{phase2prune}\DC\\{read\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{FILE} ${}{*}\|f\K\\{fopen}(\\{filename},\39\.{"rb"});{}$\7
\&{if} ${}(\|f\E\T{0}){}$\1\5
\&{return} \T{0};\2\7
\&{int} \\{togo}${}\K\\{memsize};{}$\6
\&{unsigned} \&{int} ${}{*}\|p\K\\{mem};{}$\6
\&{int} \\{seed}${}\K\T{0};{}$\7
\&{while} ${}(\\{togo}>\T{0}){}$\5
${}\{{}$\1\6
\&{unsigned} \&{int} \\{siz}${}\K(\\{togo}>\.{CHUNKSIZE}\?\.{CHUNKSIZE}:%
\\{togo});{}$\7
\&{if} ${}(\\{fread}(\|p,\39\T{1},\39\\{siz},\39\|f)\I\\{siz}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Out\ of\ data\ in\ "}\LL\\{filename}\LL\\{endl};{}$\6
\\{fclose}(\|f);\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
${}\\{seed}\K\\{datahash}(\|p,\39\\{siz},\39\\{seed});{}$\6
${}\\{togo}\MRL{-{\K}}\\{siz};{}$\6
${}\|p\MRL{+{\K}}\\{siz}/{}$\&{sizeof}(\&{unsigned} \&{int});\6
\4${}\}{}$\2\6
\&{if} ${}(\\{fread}({\AND}\\{file\_checksum},\39\&{sizeof}(\&{int}),\39\T{1},%
\39\|f)\I\T{1}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Out\ of\ data\ in\ "}\LL\\{filename}\LL\\{endl};{}$\6
\\{fclose}(\|f);\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\\{fclose}(\|f);\6
\&{if} ${}(\\{file\_checksum}\I\\{seed}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Bad\ checksum\ in\ "}\LL\\{filename}\LL\.{";\ expected\ "}\LL%
\\{file\_checksum}\LL\.{"\ but\ saw\ "}\LL\\{seed}\LL\\{endl};{}$\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\&{return} \T{1};\6
\4${}\}{}$\2\par
\fi

\M{21}Our write routine is the converse of the above.  We checksum as
we write.  Any error is fatal.  The \PB{\.{"wb"}} in the \PB{\\{fopen}} call is
to force binary mode on Windows platforms.

\Y\B\4\X11:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{phase2prune}\DC\\{write\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{FILE} ${}{*}\|f\K\\{fopen}(\\{filename},\39\.{"wb"});{}$\7
\&{if} ${}(\|f\E\T{0}){}$\1\6
\&{error} (\.{"!\ cannot\ write\ prun}\)\.{ing\ file\ to\ current\ }\)%
\.{directory"})\1\5
;\2\2\6
\&{if} ${}(\\{fwrite}(\\{mem},\39\T{1},\39\\{memsize},\39\|f)\I\\{memsize}){}$%
\1\6
\&{error} (\.{"!\ error\ writing\ pru}\)\.{ning\ table"})\1\5
;\2\2\6
\&{if} ${}(\\{fwrite}({\AND}\\{file\_checksum},\39\&{sizeof}(\&{int}),\39\T{1},%
\39\|f)\I\T{1}){}$\1\6
\&{error} (\.{"!\ error\ writing\ pru}\)\.{ning\ table"})\1\5
;\2\2\6
\\{fclose}(\|f);\6
\4${}\}{}$\2\par
\fi

\M{22}We add a routine to check the integrity of the pruning table,
perhaps at the end of a long run.  Any error is fatal.

\Y\B\4\X11:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{phase2prune}\DC\\{check\_integrity}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{file\_checksum}\I\\{datahash}(\\{mem},\39\\{memsize},\39%
\T{0})){}$\1\6
\&{error} (\.{"!\ integrity\ of\ prun}\)\.{ing\ table\ compromise}\)\.{d"})\1\5
;\2\2\6
${}\\{cout}\LL\.{"Verified\ integrity\ }\)\.{of\ phase\ two\ pruning}\)\.{\
data:\ "}\LL\\{file\_checksum}\LL\\{endl};{}$\6
\4${}\}{}$\2\par
\fi

\M{23}We now finish our initialization with the routines that read
and/or generate the file.

\Y\B\4\X8:Initialize the instance\X${}\mathrel+\E{}$\6
\&{if} ${}(\\{read\_table}(\,)\E\T{0}){}$\5
${}\{{}$\1\6
\\{gen\_table}(\,);\6
${}\\{file\_checksum}\K\\{datahash}(\\{mem},\39\\{memsize},\39\T{0});{}$\6
\&{if} ${}(\R\\{suppress\_writing}){}$\1\5
\\{write\_table}(\,);\2\6
\4${}\}{}$\2\par
\fi

\M{24}We need a solver for random positions.  It takes a maximum distance
for which the solution is useful.  If there is no solution, it returns
an empty vector (it's up to you to distinguish the case where the
position is already solved).  We also declare a utility routine
that actually does the recursion.

\Y\B\4\X12:Method declarations\X${}\mathrel+\E{}$\6
\&{static} \&{moveseq} \\{solve}(\&{const} \&{permcube} ${}{\AND}\\{pc},\39{}$%
\&{int} \\{maxlen}${}\K\T{30});{}$\7
\&{static} \&{moveseq} \\{solve}(\&{const} \&{cubepos} ${}{\AND}\\{cp},\39{}$%
\&{int} \\{maxlen}${}\K\T{30}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{permcube} \\{pc}(\\{cp});\7
\&{return} \\{solve}${}(\\{pc},\39\\{maxlen});{}$\6
\4${}\}{}$\2\7
\&{static} \&{int} \\{solve}(\&{const} \&{permcube} ${}{\AND}\\{pc},\39{}$%
\&{int} \\{togo}${},\39{}$\&{int} \\{canonstate}${},\39{}$\&{moveseq} ${}{\AND}%
\\{seq}){}$;\par
\fi

\M{25}And here we have the standard implementation of iterated depth-first
search.  The magic \PB{\T{\~227227227}} below filters out moves that are not in
$H$
all at once in the half turn metric.

\Y\B\4\X11:Method bodies\X${}\mathrel+\E{}$\6
\&{moveseq} \&{phase2prune}\DC\\{solve}(\&{const} \&{permcube} ${}{\AND}\\{pc},%
\39{}$\&{int} \\{maxlen})\1\1\2\2\6
${}\{{}$\1\6
\&{moveseq} \|r;\7
\&{for} (\&{int} \|d${}\K\\{lookup}(\\{pc});{}$ ${}\|d\Z\\{maxlen};{}$ ${}\|d%
\PP){}$\1\6
\&{if} ${}(\\{solve}(\\{pc},\39\|d,\39\.{CANONSEQSTART},\39\|r)){}$\5
${}\{{}$\1\6
${}\\{reverse}(\|r.\\{begin}(\,),\39\|r.\\{end}(\,));{}$\6
\&{break};\6
\4${}\}{}$\2\2\6
\&{return} \|r;\6
\4${}\}{}$\2\7
\&{int} \&{phase2prune}\DC\\{solve}(\&{const} \&{permcube} ${}{\AND}\\{pc},%
\39{}$\&{int} \\{togo}${},\39{}$\&{int} \\{canonstate}${},\39{}$\&{moveseq}
${}{\AND}\|r){}$\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{lookup}(\\{pc})>\\{togo}){}$\1\5
\&{return} \T{0};\2\6
\&{if} ${}(\\{pc}\E\\{identity\_pc}){}$\1\5
\&{return} \T{1};\2\6
\&{if} ${}(\\{togo}\MM\Z\T{0}){}$\1\5
\&{return} \T{0};\2\7
\&{permcube} \\{pc2};\6
\&{int} \\{mask}${}\K\&{cubepos}\DC\\{cs\_mask}(\\{canonstate})\AND\T{%
\~227227227};{}$\7
\&{while} (\\{mask})\5
${}\{{}$\1\6
\&{int} \\{ntogo}${}\K\\{togo};{}$\6
\&{int} \\{mv}${}\K\\{ffs}(\\{mask})-\T{1};{}$\7
${}\\{mask}\MRL{\AND{\K}}\\{mask}-\T{1};{}$\6
${}\\{pc2}\K\\{pc};{}$\6
${}\\{pc2}.\\{move}(\\{mv});{}$\6
\&{if} ${}(\\{solve}(\\{pc2},\39\\{ntogo},\39\&{cubepos}\DC\\{next\_cs}(%
\\{canonstate},\39\\{mv}),\39\|r)){}$\5
${}\{{}$\1\6
${}\|r.\\{push\_back}(\\{mv});{}$\6
\&{return} \T{1};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{return} \T{0};\6
\4${}\}{}$\2\par
\fi

\M{26}Test routine.

\Y\B\4\X26:\.{phase2prune\_test.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"phase2prune.h"}\6
\8\#\&{include} \.{<iostream>}\6
\&{using} \&{namespace} \&{std};\6
\&{char} \\{buf}[\T{4096}];\7
\&{int} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{lrand48}(\,)\E\T{0}){}$\1\5
\\{srand48}(\\{time}(\T{0}));\2\6
\&{phase2prune}\DC\\{init}(\T{0});\6
\&{phase2prune}\DC\\{check\_integrity}(\,);\7
\&{cubepos} \\{cp};\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{100000};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
\&{char} ${}{*}\\{tmp};{}$\6
\&{int} \\{mv}${}\K\\{random\_move}(\,);{}$\7
\&{if} (\&{kocsymm}\DC\\{in\_Kociemba\_group}(\\{mv}))\5
${}\{{}$\1\6
${}\\{cp}.\\{movepc}(\\{mv});{}$\6
\4${}\}{}$\2\7
\&{int} \\{lookd}${}\K\&{phase2prune}\DC\\{lookup}(\\{cp});{}$\7
${}\\{cout}\LL\.{"Distance\ "}\LL\\{lookd}\LL\\{endl};{}$\7
\&{moveseq} \|s${}\K\&{phase2prune}\DC\\{solve}(\\{cp});{}$\6
\&{cubepos} \\{cpt}${}\K\\{cp};{}$\7
\&{for} (\&{unsigned} \&{int} \|j${}\K\T{0};{}$ ${}\|j<\|s.\\{size}(\,);{}$ ${}%
\|j\PP){}$\1\5
${}\\{cpt}.\\{movepc}(\|s[\|j]);{}$\2\6
${}\&{cubepos}\DC\\{append\_moveseq}(\\{tmp}\K\\{buf},\39\|s);{}$\6
${}\\{cout}\LL\.{"Solution\ length\ "}\LL\|s.\\{size}(\,)\LL\.{"\ "}\LL\\{buf}%
\LL\\{endl};{}$\6
\&{if} ${}(\\{cpt}\I\\{identity\_cube}){}$\1\6
\&{error} (\.{"!\ bad\ solve"})\1\5
;\2\2\6
\&{if} ((\&{unsigned} \&{int}) \\{lookd}${}>\|s.\\{size}(\,)){}$\1\6
\&{error} (\.{"!\ solution\ too\ shor}\)\.{t"})\1\5
;\2\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\inx
\fin
\con
