\input cwebmac
\def\mod{\mathop{mod}}


\N{1}{1}Introduction.
Phase one of Kociemba's two-phase algorithm involves finding a
sequence of moves that takes an arbitrary position into the $H$ group,
generated by $\{U,F2,R2,D,B2,L2\}$.  This pruning table is the heart
of both the general Kociemba two-phase algorithm and the coset solver
based on it, so careful attention to performance must be paid.

Most pruning tables just give an estimate of the depth of the current
position.  For this particular pruning table, we want to not only give
the exact depth (to reduce false search paths), but also give
information on precisely which moves take you closer to solved.  By
doing this, we can eliminate almost all false paths in the search.
Making the pruning table larger by increasing the size of each entry
does not slow things down much, because a cache miss is a cache miss
whether you access a bit of the cache line or all 32 bytes, and the
performance of this pruning table is dominated by the cache (and TLB)
misses it incurs.

The Schreier coset graph, as implemented in the \PB{\&{kocsymm}} class, has
size $3^7\cdot 2^{11}\cdot{12\choose 4}$ which is 2,217,093,120
entries.  This coset has 16-way symmetry, so we reduce the size of the
pruning table to about 170,000,000 entries; the remapping of \PB{\&{kocsymm}}
is reasonably fast requiring only small tables.  (This is a bit more
than what you would expect, because we only do an approximate
reduction by symmetry for speed, and thus have a few more table
entries.)

Each entry should contain the depth (which can range from 0 to 12) as
well as information on whether each move brings you closer to solved,
keeps you the same distance from solved, or takes you further away
from solved.  (Solved here means in the group $H$, not completely
solved).  Normally in the half turn metric this would require more
than 32 bits per entry
($3^{18}\cdot 13>2^{32}$) but we can reduce this pretty easily.  For a
particular face, you would expect there to be 27 possibilities, a
factor of three contributed by each possible move of that face.
Consider the moves U1 and U2.  If U1 brings you closer to solved, then
U2 cannot bring you further from solved, because the sequence U2U3 is
identical to U1.  Thus, moves that share the same face twist can
differ in their impact on distance by at most one.  This eliminates 12
of the possibilities, leaving only 15 possibilities for each face.
This requires four bits, so we can fit each entry in 32 bits: 4 bits
for each of the six faces, and another four bits for the distance.

In theory with this information we do not even need to store the
distance, since we can solve each position using just the incremental
information to obtain the initial distance, and then we can keep track
of the actual distance incrementally.  For the moment, for simplicity,
we use four-byte entries with explicit distance.  We'll consider how
to take advantage of some of the extra bits later.

Our basic API is straightforward.  We have an initialization routine,
and a lookup method that takes the position to look up, the current
number of moves remaining for the current search, and by reference a
variable to return a bitmask of which moves to consider for the next
level of search.  Everything in this class is static; there are no
instance methods or fields.

\Y\B\4\X1:\.{phase1prune.h }\X${}\E{}$\6
\8\#\&{ifndef} \.{PHASE1PRUNE\_H}\6
\8\#\&{define} \.{PHASE1PRUNE\_H}\6
\8\#\&{include} \.{"kocsymm.h"}\6
\X6:Constant declarations\X;\7
\&{class} \&{phase1prune} ${}\{{}$\1\6
\4\&{public}:\6
\&{static} \&{void} \\{init}(\&{int} \\{suppress\_writing}${}\K\T{0});{}$\6
\&{static} \&{int} \\{lookup}(\&{const} \&{kocsymm} ${}{\AND}\\{kc},\39{}$%
\&{int} ${}{\AND}\\{mask});{}$\7
\X8:Method declarations\X\6
\X3:Data declarations\X\2\6
${}\};{}$\6
\8\#\&{endif}\par
\fi

\M{2}Our initialization routine is the first component of our C++ file.
It is protected against multiple invocation by a method-local static.

\Y\B\4\X2:\.{phase1prune.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"phase1prune.h"}\6
\8\#\&{include} \.{<iostream>}\6
\8\#\&{include} \.{<cstdio>}\6
\&{using} \&{namespace} \&{std};\7
\X4:Data instantiations\X\6
\X5:Utility functions\X\6
\X9:Method bodies\X\7
\&{void} \&{phase1prune}\DC\\{init}(\&{int} \\{suppress\_writing})\1\1\2\2\6
${}\{{}$\1\6
\&{static} \&{int} \\{initialized}${}\K\T{0};{}$\7
\&{if} (\\{initialized})\1\5
\&{return};\2\6
${}\\{initialized}\K\T{1};{}$\6
\X7:Initialize the instance\X\6
\4${}\}{}$\2\par
\A22.\fi

\M{3}We need a memory array to store the result, a static variable to
hold the size of the array, and another static variable to hold
the checksum of the array.  We also need a filename for the file.

\Y\B\4\X3:Data declarations\X${}\E{}$\6
\&{static} \&{unsigned} \&{int} \\{memsize};\6
\&{static} \&{unsigned} \&{char} ${}{*}\\{mem};{}$\6
\&{static} \&{int} \\{file\_checksum};\6
\&{static} \&{const} \&{char} ${}{*\&{const}\ }\\{filename}{}$;\par
\U1.\fi

\M{4}All these must be instantiated.  For the filename, we use the
name given below to indicate phase 1 pruning data, halfturn metric.

\Y\B\4\X4:Data instantiations\X${}\E{}$\6
\&{unsigned} \&{int} \&{phase1prune}\DC\\{memsize};\6
\&{unsigned} \&{char} ${}{*}\&{phase1prune}\DC\\{mem};{}$\6
\&{int} \&{phase1prune}\DC\\{file\_checksum};\6
\&{const} \&{char} ${}{*\&{const}\ }\&{phase1prune}\DC\\{filename}\K%
\.{"p1p1h.dat"}{}$;\par
\A18.
\U2.\fi

\M{5}We need a routine to do a checksum of the file, to verify integrity.
We use a simplistic hash function.  Note that this function expects an
array pointing to \PB{\&{unsigned} \&{int}}, not \PB{\&{unsigned} \&{char}}
like our \PB{\\{mem}}
array; we use a bit of coercion to make this work.  These data files
are not interchangeable across different endian architectures; the
checksums will be different.  We make it file static in case we
use a different one somewhere else.

\Y\B\4\X5:Utility functions\X${}\E{}$\6
\&{static} \&{int} \\{datahash}(\&{unsigned} \&{int} ${}{*}\\{dat},\39{}$%
\&{int} \\{sz}${},\39{}$\&{int} \\{seed})\1\1\2\2\6
${}\{{}$\1\6
\&{while} ${}(\\{sz}>\T{0}){}$\5
${}\{{}$\1\6
${}\\{sz}\MRL{-{\K}}\T{4};{}$\6
${}\\{seed}\K\T{37}*\\{seed}+{*}\\{dat}\PP;{}$\6
\4${}\}{}$\2\6
\&{return} \\{seed};\6
\4${}\}{}$\2\par
\U2.\fi

\M{6}We use a constant to indicate the count of bytes needed per entry.

\Y\B\4\X6:Constant declarations\X${}\E{}$\6
\&{const} \&{int} \.{BYTES\_PER\_ENTRY}${}\K\T{4}{}$;\par
\U1.\fi

\M{7}Our initialization routine calculates the memory size and allocates
the array.  We use a single contiguous array; even on 32-bit
architectures it should be straightforward to get about 700MB of
contiguous memory---at least early in the program's lifetime.

\Y\B\4\X7:Initialize the instance\X${}\E{}$\6
$\\{memsize}\K\.{BYTES\_PER\_ENTRY}*\.{CORNERRSYMM}*\.{EDGEOSYMM}*%
\.{EDGEPERM};{}$\6
${}\\{mem}\K{}$(\&{unsigned} \&{char} ${}{*}){}$ \\{malloc}(\\{memsize});\6
\&{if} ${}(\\{mem}\E\T{0}){}$\1\6
\&{error} (\.{"!\ no\ memory"})\1\5
;\2\2\par
\As15, 20\ETs21.
\U2.\fi

\M{8}We need methods to generate the table, read it, write it, and check
it for integrity.

\Y\B\4\X8:Method declarations\X${}\E{}$\6
\&{static} \&{void} \\{gen\_table}(\,);\6
\&{static} \&{int} \\{read\_table}(\,);\6
\&{static} \&{void} \\{write\_table}(\,);\6
\&{static} \&{void} \\{check\_integrity}(\,);\par
\A16.
\U1.\fi

\M{9}Our generate table routine is next.  We iterate over the distances,
finding each position at the current depth, and extending it by one move.

\Y\B\4\X9:Method bodies\X${}\E{}$\6
\&{void} \&{phase1prune}\DC\\{gen\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{memset}(\\{mem},\39{-}\T{1},\39\\{memsize});{}$\6
${}\\{mem}[\T{0}]\K\T{0};{}$\7
\&{int} \\{seen}${}\K\T{1};{}$\7
${}\\{cout}\LL\.{"Gen\ phase1"}\LL\\{flush};{}$\6
\&{for} (\&{int} \|d${}\K\T{1};{}$  ; ${}\|d\PP){}$\5
${}\{{}$\1\6
\&{int} \\{lastiter}${}\K(\\{seen}\E\.{CORNERRSYMM}*\.{EDGEOSYMM}*%
\.{EDGEPERM});{}$\6
\&{int} \\{seek}${}\K\|d-\T{1};{}$\6
\&{int} \\{at}${}\K\T{0};{}$\7
\&{for} (\&{int} \\{cs}${}\K\T{0};{}$ ${}\\{cs}<\.{CORNERRSYMM};{}$ ${}\\{cs}%
\PP){}$\5
${}\{{}$\1\6
\&{int} \\{csymm}${}\K\&{kocsymm}\DC\\{cornersymm\_expand}[\\{cs}];{}$\7
\&{for} (\&{int} \\{eosymm}${}\K\T{0};{}$ ${}\\{eosymm}<\.{EDGEOSYMM};{}$ ${}%
\\{eosymm}\PP){}$\1\6
\&{for} (\&{int} \\{epsymm}${}\K\T{0};{}$ ${}\\{epsymm}<\.{EDGEPERM};{}$ ${}%
\\{epsymm}\PP,\39\\{at}\MRL{+{\K}}\.{BYTES\_PER\_ENTRY}){}$\1\6
\&{if} ${}(\\{mem}[\\{at}]\E\\{seek}){}$\5
${}\{\X10:Handle one position\X\}{}$\2\2\6
\4${}\}{}$\2\6
${}\\{cout}\LL\.{"\ "}\LL\|d\LL\\{flush};{}$\6
\&{if} (\\{lastiter})\1\5
\&{break};\2\6
\4${}\}{}$\2\6
${}\\{cout}\LL\.{"\ done."}\LL\\{endl}\LL\\{flush};{}$\6
\4${}\}{}$\2\par
\As12, 13, 14, 17\ETs19.
\U2.\fi

\M{10}For each position, we consider all possible moves, and track the
distances of those moves.  Then, we combine these results into three
bytes.  We keep track of which moves bring us closer, so later perhaps
we can optimize the case where there's only one such possibility.

\Y\B\4\X10:Handle one position\X${}\E{}$\6
\&{int} \\{deltadist}[\.{NMOVES}];\7
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
\&{int} \\{rd}${}\K\T{0};{}$\6
\&{kocsymm} ${}\\{kc}(\\{csymm},\39\\{eosymm},\39\\{epsymm});{}$\7
${}\\{kc}.\\{move}(\\{mv});{}$\6
${}\\{corner\_mapinfo}\AND\\{cm}\K\&{kocsymm}\DC\\{cornersymm}[\\{kc}.%
\\{csymm}];{}$\6
\&{for} (\&{int} \|m${}\K\\{cm}.\\{minmap};{}$ ${}\\{cm}.\\{minbits}\GG\|m;{}$
${}\|m\PP){}$\1\6
\&{if} ${}((\\{cm}.\\{minbits}\GG\|m)\AND\T{1}){}$\5
${}\{{}$\1\6
\&{int} \\{deosymm}${}\K\&{kocsymm}\DC\\{edgeomap}[\&{kocsymm}\DC\\{edgepxor}[%
\\{kc}.\\{epsymm}][\|m\GG\T{3}]\XOR\\{kc}.\\{eosymm}][\|m];{}$\6
\&{int} \\{depsymm}${}\K\&{kocsymm}\DC\\{edgepmap}[\\{kc}.\\{epsymm}][\|m];{}$\6
\&{int} \\{dat}${}\K((\\{cm}.\\{csymm}*\.{EDGEOSYMM}+\\{deosymm})*\.{EDGEPERM}+%
\\{depsymm})*\.{BYTES\_PER\_ENTRY};{}$\7
${}\\{rd}\K\\{mem}[\\{dat}];{}$\6
\&{if} ${}(\\{rd}\E\T{255}){}$\5
${}\{{}$\1\6
${}\\{rd}\K\|d;{}$\6
${}\\{mem}[\\{dat}]\K\\{rd};{}$\6
${}\\{seen}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\6
${}\\{deltadist}[\\{mv}]\K\\{rd}-\\{seek};{}$\6
\4${}\}{}$\2\6
\X11:Encode \PB{\\{deltadist}}\X\par
\U9.\fi

\M{11}We now have the delta distances for all \PB{\.{NMOVES}} moves.  We need
to encode
this data into the remaining bits of the lookup entry.
If the most significant bit of a nybble
is set, that means the distances are all nonnegative; if the most
significant bit is clear, then the distances are all nonpositive.  The
least significant three bits indicate for each move whether the higher
or lower value is appropriate; a zero means the lower value, and a one
means the higher value.  If none of the three moves have an impact, we
choose the value 8 (and not the value 7, which encodes the same
semantics).
We collect the information from opposite
faces into the same byte value to make later remapping more efficient.

\Y\B\4\X11:Encode \PB{\\{deltadist}}\X${}\E{}$\6
\&{for} (\&{int} \|b${}\K\T{0};{}$ ${}\|b<\T{3};{}$ ${}\|b\PP){}$\5
${}\{{}$\1\6
\&{int} \|v${}\K\T{0};{}$\6
\&{int} \\{clim}${}\K\T{1};{}$\7
\&{for} (\&{int} \|c${}\K\\{clim};{}$ ${}\|c\G\T{0};{}$ ${}\|c\MM){}$\5
${}\{{}$\1\6
\&{int} \\{vv}${}\K\T{0};{}$\6
\&{int} \\{cnts}[\T{3}];\7
${}\\{cnts}[\T{0}]\K\\{cnts}[\T{1}]\K\\{cnts}[\T{2}]\K\T{0};{}$\6
\&{for} (\&{int} \|t${}\K\T{2};{}$ ${}\|t\G\T{0};{}$ ${}\|t\MM){}$\5
${}\{{}$\1\6
${}\\{vv}\K\T{2}*\\{vv}+\\{deltadist}[\T{3}*\|b+\T{9}*\|c+\|t];{}$\6
${}\\{cnts}[\T{1}+\\{deltadist}[\T{3}*\|b+\T{9}*\|c+\|t]]\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{cnts}[\T{0}]>\T{0}\W\\{cnts}[\T{2}]>\T{0}){}$\1\6
\&{error} (\.{"!\ bad\ delta\ distanc}\)\.{e\ values\ within\ one\ }\)\.{face\
turn\ set"})\1\5
;\2\2\6
\&{if} (\\{cnts}[\T{0}])\SHC{ combination of zeros and -1's }\1\6
${}\\{vv}\MRL{+{\K}}\T{7};{}$\2\6
\&{else}\SHC{ combination of zeros and ones, or just zeros }\1\6
${}\\{vv}\MRL{+{\K}}\T{8};{}$\2\6
${}\|v\K\T{16}*\|v+\\{vv};{}$\6
\4${}\}{}$\2\6
${}\\{mem}[\\{at}+\|b+\T{1}]\K\|v;{}$\6
\4${}\}{}$\2\par
\U10.\fi

\N{1}{12}Input and Output.
Our read routine is straightforward; we return 1 on success, and
0 on failure.  We could read the whole thing at once and then checksum
it afterwards, but we choose to do it in chunks that fit in cache.
The \PB{\.{"rb"}} in the \PB{\\{fopen}} call is to force binary mode on Windows
platforms.

\Y\B\4\X9:Method bodies\X${}\mathrel+\E{}$\6
\&{const} \&{int} \.{CHUNKSIZE}${}\K\T{65536};{}$\7
\&{int} \&{phase1prune}\DC\\{read\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{FILE} ${}{*}\|f\K\\{fopen}(\\{filename},\39\.{"rb"});{}$\7
\&{if} ${}(\|f\E\T{0}){}$\1\5
\&{return} \T{0};\2\7
\&{int} \\{togo}${}\K\\{memsize};{}$\6
\&{unsigned} \&{char} ${}{*}\|p\K\\{mem};{}$\6
\&{int} \\{seed}${}\K\T{0};{}$\7
\&{while} ${}(\\{togo}>\T{0}){}$\5
${}\{{}$\1\6
\&{unsigned} \&{int} \\{siz}${}\K(\\{togo}>\.{CHUNKSIZE}\?\.{CHUNKSIZE}:%
\\{togo});{}$\7
\&{if} ${}(\\{fread}(\|p,\39\T{1},\39\\{siz},\39\|f)\I\\{siz}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Out\ of\ data\ in\ "}\LL\\{filename}\LL\\{endl};{}$\6
\\{fclose}(\|f);\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
${}\\{seed}\K\\{datahash}{}$((\&{unsigned} \&{int} ${}{*}){}$ \|p${},\39%
\\{siz},\39\\{seed});{}$\6
${}\\{togo}\MRL{-{\K}}\\{siz};{}$\6
${}\|p\MRL{+{\K}}\\{siz};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{fread}({\AND}\\{file\_checksum},\39\&{sizeof}(\&{int}),\39\T{1},%
\39\|f)\I\T{1}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Out\ of\ data\ in\ "}\LL\\{filename}\LL\\{endl};{}$\6
\\{fclose}(\|f);\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\\{fclose}(\|f);\6
\&{if} ${}(\\{file\_checksum}\I\\{seed}){}$\5
${}\{{}$\1\6
${}\\{cerr}\LL\.{"Bad\ checksum\ in\ "}\LL\\{filename}\LL\.{";\ expected\ "}\LL%
\\{file\_checksum}\LL\.{"\ but\ saw\ "}\LL\\{seed}\LL\\{endl};{}$\6
\&{return} \T{0};\6
\4${}\}{}$\2\6
\&{return} \T{1};\6
\4${}\}{}$\2\par
\fi

\M{13}Our write routine is the converse of the above.  We checksum as
we write.  Any error is fatal.  The \PB{\.{"wb"}} in the \PB{\\{fopen}} call is
to force binary mode on Windows platforms.

\Y\B\4\X9:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{phase1prune}\DC\\{write\_table}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{FILE} ${}{*}\|f\K\\{fopen}(\\{filename},\39\.{"wb"});{}$\7
\&{if} ${}(\|f\E\T{0}){}$\1\6
\&{error} (\.{"!\ cannot\ write\ prun}\)\.{ing\ file\ to\ current\ }\)%
\.{directory"})\1\5
;\2\2\6
\&{if} ${}(\\{fwrite}(\\{mem},\39\T{1},\39\\{memsize},\39\|f)\I\\{memsize}){}$%
\1\6
\&{error} (\.{"!\ error\ writing\ pru}\)\.{ning\ table"})\1\5
;\2\2\6
\&{if} ${}(\\{fwrite}({\AND}\\{file\_checksum},\39\&{sizeof}(\&{int}),\39\T{1},%
\39\|f)\I\T{1}){}$\1\6
\&{error} (\.{"!\ error\ writing\ pru}\)\.{ning\ table"})\1\5
;\2\2\6
\\{fclose}(\|f);\6
\4${}\}{}$\2\par
\fi

\M{14}We add a routine to check the integrity of the pruning table,
perhaps at the end of a long run.  Any error is fatal.

\Y\B\4\X9:Method bodies\X${}\mathrel+\E{}$\6
\&{void} \&{phase1prune}\DC\\{check\_integrity}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{file\_checksum}\I\\{datahash}{}$((\&{unsigned} \&{int} ${}{*}){}$
\\{mem}${},\39\\{memsize},\39\T{0})){}$\1\6
\&{error} (\.{"!\ integrity\ of\ prun}\)\.{ing\ table\ compromise}\)\.{d"})\1\5
;\2\2\6
${}\\{cout}\LL\.{"Verified\ integrity\ }\)\.{of\ phase\ one\ pruning}\)\.{\
data:\ "}\LL\\{file\_checksum}\LL\\{endl};{}$\6
\4${}\}{}$\2\par
\fi

\M{15}We now finish our initialization with the routines that read
and/or generate the file.

\Y\B\4\X7:Initialize the instance\X${}\mathrel+\E{}$\6
\&{if} ${}(\\{read\_table}(\,)\E\T{0}){}$\5
${}\{{}$\1\6
\\{gen\_table}(\,);\6
${}\\{file\_checksum}\K\\{datahash}{}$((\&{unsigned} \&{int} ${}{*}){}$ %
\\{mem}${},\39\\{memsize},\39\T{0});{}$\6
\&{if} ${}(\R\\{suppress\_writing}){}$\1\5
\\{write\_table}(\,);\2\6
\4${}\}{}$\2\par
\fi

\M{16}Lookup routines, and a solve routine.

\Y\B\4\X8:Method declarations\X${}\mathrel+\E{}$\6
\&{static} \&{int} \\{lookup}(\&{const} \&{kocsymm} ${}{\AND}\\{kc});{}$\6
\&{static} \&{int} \\{lookup}(\&{const} \&{kocsymm} ${}{\AND}\\{kc},\39{}$%
\&{int} \\{togo}${},\39{}$\&{int} ${}{\AND}\\{nextmovemask});{}$\6
\&{static} \&{moveseq} \\{solve}(\&{kocsymm} \\{kc});\par
\fi

\M{17}Looking up the distance is quick, based on the code we've already
seen.

\Y\B\4\X9:Method bodies\X${}\mathrel+\E{}$\6
\&{int} \&{phase1prune}\DC\\{lookup}(\&{const} \&{kocsymm} ${}{\AND}\\{kc}){}$%
\1\1\2\2\6
${}\{{}$\1\6
${}\\{corner\_mapinfo}\AND\\{cm}\K\&{kocsymm}\DC\\{cornersymm}[\\{kc}.%
\\{csymm}];{}$\7
\&{int} \|m${}\K\\{cm}.\\{minmap};{}$\6
\&{int} \|r${}\K\\{mem}[\.{BYTES\_PER\_ENTRY}*(((\\{cm}.\\{csymm}*%
\.{EDGEOSYMM})+\&{kocsymm}\DC\\{edgeomap}[\&{kocsymm}\DC\\{edgepxor}[\\{kc}.%
\\{epsymm}][\|m\GG\T{3}]\XOR\\{kc}.\\{eosymm}][\|m])*\T{495}+\&{kocsymm}\DC%
\\{edgepmap}[\\{kc}.\\{epsymm}][\|m])];{}$\7
\&{return} \|r;\6
\4${}\}{}$\2\par
\fi

\M{18}A more important lookup routine, though, is the one that not only gives
us the distance, but also tells us which moves take us closer to solved.
At the first level, we have that information directly in the table.
Unfortunately, because we remap our position to perform the lookup, we
also have to remap the bitmap from the table.  To do this, we need to
take into account the remapping (and how it reorders the faces, and
possibly negates the twists) and whether the number of moves left is
equal to or in excess of the number of moves to go.  We use a single
array \PB{\\{map\_phase1}} that is indexed by all of this data and returns the
relevant bits indicating what moves are valid.  For each of the sixteen
possible reorientations, we also have an additional array that gives
the appropriate offsets.  We only use this here so we make it file static
rather than class static.

\Y\B\4\X4:Data instantiations\X${}\mathrel+\E{}$\6
\&{static} \&{unsigned} \&{char} \\{map\_phase1\_offsets}[\.{KOCSYMM}][\T{3}];\6
\&{static} \&{int} \\{map\_phase1}[\T{2}][\T{12}][\T{256}];\par
\fi

\M{19}Assuming those arrays are filled in appropriately, our main lookup
routine looks like this.

\Y\B\4\X9:Method bodies\X${}\mathrel+\E{}$\6
\&{int} \&{phase1prune}\DC\\{lookup}(\&{const} \&{kocsymm} ${}{\AND}\\{kc},%
\39{}$\&{int} \\{togo}${},\39{}$\&{int} ${}{\AND}\\{nextmovemask}){}$\1\1\2\2\6
${}\{{}$\1\6
${}\\{corner\_mapinfo}\AND\\{cm}\K\&{kocsymm}\DC\\{cornersymm}[\\{kc}.%
\\{csymm}];{}$\7
\&{int} \|m${}\K\\{cm}.\\{minmap};{}$\6
\&{int} \\{off}${}\K\.{BYTES\_PER\_ENTRY}*(((\\{cm}.\\{csymm}*\.{EDGEOSYMM})+%
\&{kocsymm}\DC\\{edgeomap}[\&{kocsymm}\DC\\{edgepxor}[\\{kc}.\\{epsymm}][\|m\GG%
\T{3}]\XOR\\{kc}.\\{eosymm}][\|m])*\T{495}+\&{kocsymm}\DC\\{edgepmap}[\\{kc}.%
\\{epsymm}][\|m]);{}$\6
\&{int} \|r${}\K\\{mem}[\\{off}];{}$\7
\&{if} ${}(\\{togo}<\|r){}$\5
${}\{{}$\1\6
${}\\{nextmovemask}\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{togo}>\|r+\T{1}){}$\5
${}\{{}$\1\6
${}\\{nextmovemask}\K\.{ALLMOVEMASK};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\&{int}({*}\|p)[\T{256}]\K\\{map\_phase1}[\\{togo}-\|r];{}$\7
\&{unsigned} \&{char} ${}{*}\|o\K\\{map\_phase1\_offsets}[\|m];{}$\7
${}\\{nextmovemask}\K\|p[\|o[\T{0}]][\\{mem}[\\{off}+\T{1}]]+\|p[\|o[\T{1}]][%
\\{mem}[\\{off}+\T{2}]]+\|p[\|o[\T{2}]][\\{mem}[\\{off}+\T{3}]];{}$\6
\4${}\}{}$\2\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\fi

\M{20}Initializing the two arrays is a little tricky.  First we initialize
the offsets; we use a key that uses the least significant bit to
indicate a negative orientation, the next bit to indicate that the
faces are flipped, and the next two bits to indicate what axis the
remapping maps this axis to.

\Y\B\4\X7:Initialize the instance\X${}\mathrel+\E{}$\6
\&{for} (\&{int} \|m${}\K\T{0};{}$ ${}\|m<\.{KOCSYMM};{}$ ${}\|m\PP){}$\5
${}\{{}$\1\6
\&{for} (\&{int} \|f${}\K\T{0};{}$ ${}\|f<\T{3};{}$ ${}\|f\PP){}$\5
${}\{{}$\1\6
\&{int} \\{mv}${}\K\|f*\.{TWISTS};{}$\6
\&{int} \\{mv2}${}\K\&{cubepos}\DC\\{move\_map}[\|m][\\{mv}];{}$\6
\&{int} \\{f2}${}\K\\{mv2}/\.{TWISTS};{}$\6
\&{int} \\{key}${}\K\T{0};{}$\7
\&{if} ${}(\\{mv2}\MOD\.{TWISTS}\E\.{TWISTS}-\T{1}{}$)\SHC{ negative
orientation }\1\6
${}\\{key}\PP;{}$\2\6
\&{if} ${}(\\{f2}\G\T{3}{}$)\SHC{ flip the faces }\1\6
${}\\{key}\MRL{+{\K}}\T{2};{}$\2\6
${}\\{key}\MRL{+{\K}}\T{4}*(\\{f2}\MOD\T{3}){}$;\SHC{ where the low order face
maps }\6
${}\\{map\_phase1\_offsets}[\&{cubepos}\DC\\{invm}[\|m]][\|f]\K\\{key};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{21}Now we fill in the actual bit array itself.  We essentially just
perform the operations described in the key.  We calculate the
low nybble first; then we iterate to combine it with the high nybble.

\Y\B\4\X7:Initialize the instance\X${}\mathrel+\E{}$\6
\&{for} (\&{int} \\{slack}${}\K\T{0};{}$ ${}\\{slack}<\T{2};{}$ ${}\\{slack}%
\PP){}$\5
${}\{{}$\1\6
\&{for} (\&{int} \\{key}${}\K\T{0};{}$ ${}\\{key}<\T{12};{}$ ${}\\{key}\PP){}$\5
${}\{{}$\1\6
\&{int} \\{nv}[\T{16}];\7
\&{for} (\&{int} \\{nyb}${}\K\T{0};{}$ ${}\\{nyb}<\T{16};{}$ ${}\\{nyb}\PP){}$\5
${}\{{}$\1\6
\&{int} \\{bits}${}\K\T{0};{}$\7
\&{if} ${}(\\{slack}\W\\{nyb}\Z\T{7}){}$\5
${}\{{}$\SHC{ always, any move }\1\6
${}\\{bits}\K\T{7};{}$\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{slack}\E\T{0}\W\\{nyb}\G\T{7}){}$\5
${}\{{}$\1\6
${}\\{bits}\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{bits}\K\T{7}-(\\{nyb}\AND\T{7});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{key}\AND\T{1}{}$)\SHC{ negate the twist if key says so }\1\6
${}\\{bits}\K((\\{bits}\AND\T{1})\LL\T{2})+(\\{bits}\AND\T{2})+(\\{bits}\GG%
\T{2});{}$\2\6
\&{if} ${}(\\{key}\AND\T{2}{}$)\SHC{ flip the faces if key says so }\1\6
${}\\{bits}\MRL{{\LL}{\K}}\T{3}*\.{TWISTS};{}$\2\6
${}\\{bits}\MRL{{\LL}{\K}}\.{TWISTS}*(\\{key}\GG\T{2}){}$;\SHC{ shift to
correct face }\6
${}\\{nv}[\\{nyb}]\K\\{bits};{}$\6
\4${}\}{}$\2\7
\&{int} ${}{*}\|a\K\\{map\_phase1}[\\{slack}][\\{key}];{}$\7
\&{for} (\&{int} \\{byte}${}\K\T{0};{}$ ${}\\{byte}<\T{256};{}$ ${}\\{byte}%
\PP){}$\1\5
${}\|a[\\{byte}]\K\\{nv}[\\{byte}\AND\T{15}]\OR(((\\{nv}[\\{byte}\GG\T{4}]\LL(%
\T{3}*\.{TWISTS}))\OR(\\{nv}[\\{byte}\GG\T{4}]\GG(\T{3}*\.{TWISTS})))\AND\T{%
\~777777});{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{22}We also provide a quick and dirty solve routine.

\Y\B\4\X2:\.{phase1prune.cpp }\X${}\mathrel+\E{}$\6
\&{moveseq} \&{phase1prune}\DC\\{solve}(\&{kocsymm} \\{kc})\1\1\2\2\6
${}\{{}$\1\6
\&{moveseq} \|r;\6
\&{int} \|d${}\K\&{phase1prune}\DC\\{lookup}(\\{kc});{}$\7
\&{while} ${}(\|d>\T{0}){}$\5
${}\{{}$\1\6
\&{int} \\{nmm}${}\K\T{0};{}$\6
\&{int} \|t${}\K\&{phase1prune}\DC\\{lookup}(\\{kc},\39\|d,\39\\{nmm});{}$\7
\&{if} ${}(\|t\E\T{0}){}$\1\5
\&{break};\2\6
\&{if} ${}(\|t\I\|d){}$\1\6
\&{error} (\.{"!\ did\ not\ make\ prog}\)\.{ress"})\1\5
;\2\2\6
\&{if} ${}(\\{nmm}\E\T{0}){}$\1\6
\&{error} (\.{"!\ no\ solution?"})\1\5
;\2\2\7
\&{int} \\{mv}${}\K\\{ffs}(\\{nmm})-\T{1};{}$\7
${}\|r.\\{push\_back}(\\{mv});{}$\6
${}\\{kc}.\\{move}(\\{mv});{}$\6
${}\|d\MM;{}$\6
\4${}\}{}$\2\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\fi

\M{23}Our test routines.

\Y\B\4\X23:\.{phase1prune\_test.cpp }\X${}\E{}$\6
\8\#\&{include} \.{"phase1prune.h"}\6
\8\#\&{include} \.{<iostream>}\6
\&{using} \&{namespace} \&{std};\7
\&{int} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1%
\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{lrand48}(\,)\E\T{0}){}$\1\5
\\{srand48}(\\{time}(\T{0}));\2\6
\&{phase1prune}\DC\\{init}(\,);\7
\&{int} \|t[\T{10000}];\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\5
${}\|t[\|i]\K\\{random\_move}(\,);{}$\2\7
\&{kocsymm} \\{kc};\7
\X24:Check next move info\X\6
\X25:Check basic lookup performance\X\6
\X26:Check extended lookup performance\X\6
\X27:Check solution performance\X\6
\4${}\}{}$\2\par
\fi

\M{24}Check that the next move information is correct.

\Y\B\4\X24:Check next move info\X${}\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{move}(\|t[\|i]);{}$\7
\&{int} \|d${}\K\&{phase1prune}\DC\\{lookup}(\\{kc});{}$\7
\&{for} (\&{int} \\{d2}${}\K\|d-\T{1};{}$ ${}\\{d2}\Z\|d+\T{2};{}$ ${}\\{d2}%
\PP){}$\5
${}\{{}$\1\6
\&{int} \\{nextmovemask}${}\K\T{0};{}$\6
\&{kocsymm} \\{kc2};\6
\&{int} \\{dt}${}\K\&{phase1prune}\DC\\{lookup}(\\{kc},\39\\{d2},\39%
\\{nextmovemask});{}$\7
\&{if} ${}(\\{dt}\I\|d){}$\1\6
\&{error} (\.{"mismatch\ on\ lookup"})\1\5
;\2\2\7
\&{int} \\{bc}${}\K\T{0};{}$\7
\&{for} (\&{int} \\{mv}${}\K\T{0};{}$ ${}\\{mv}<\.{NMOVES};{}$ ${}\\{mv}\PP){}$%
\5
${}\{{}$\1\6
${}\\{kc2}\K\\{kc};{}$\6
${}\\{kc2}.\\{move}(\\{mv});{}$\6
${}\\{dt}\K\&{phase1prune}\DC\\{lookup}(\\{kc2});{}$\6
\&{if} ${}(\\{dt}<\\{d2}){}$\1\5
${}\\{bc}\MRL{{\OR}{\K}}(\T{1}\LL\\{mv});{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{nextmovemask}\I\\{bc}){}$\1\6
\&{error} (\.{"!\ move\ mask\ error"})\1\5
;\2\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U23.\fi

\M{25}Check how fast we can look up.

\Y\B\4\X25:Check basic lookup performance\X${}\E{}$\6
\&{int} \\{sum}${}\K\T{0};{}$\7
\\{duration}(\,);\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{move}(\|t[\|j]);{}$\6
${}\\{sum}\MRL{+{\K}}\&{phase1prune}\DC\\{lookup}(\\{kc});{}$\6
\4${}\}{}$\2\2\6
${}\\{cout}\LL\.{"Did\ 100M\ basic\ look}\)\.{ups\ in\ "}\LL\\{duration}(\,)\LL%
\.{"\ sum\ "}\LL\\{sum}\LL\\{endl}{}$;\par
\U23.\fi

\M{26}Check how fast we can look up with extended info.

\Y\B\4\X26:Check extended lookup performance\X${}\E{}$\6
\&{int} \\{prev}${}\K\T{10};{}$\6
\&{int} \\{nextmovemask}${}\K\T{0};{}$\7
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{10000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{move}(\|t[\|j]);{}$\7
\&{int} \|r${}\K\&{phase1prune}\DC\\{lookup}(\\{kc},\39\\{prev},\39%
\\{nextmovemask});{}$\7
${}\\{sum}\MRL{+{\K}}\|r+\\{nextmovemask};{}$\6
${}\\{prev}\K\|r;{}$\6
\4${}\}{}$\2\2\6
${}\\{cout}\LL\.{"Did\ 100M\ extended\ l}\)\.{ookups\ in\ "}\LL\\{duration}(\,)%
\LL\.{"\ sum\ "}\LL\\{sum}\LL\\{endl}{}$;\par
\U23.\fi

\M{27}Check how fast we can solve.

\Y\B\4\X27:Check solution performance\X${}\E{}$\6
\&{for} (\&{int} \|i${}\K\T{0};{}$ ${}\|i<\T{1000};{}$ ${}\|i\PP){}$\1\6
\&{for} (\&{int} \|j${}\K\T{0};{}$ ${}\|j<\T{10000};{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
${}\\{kc}.\\{move}(\|t[\|j]);{}$\6
\&{phase1prune}\DC\\{solve}(\\{kc});\6
\4${}\}{}$\2\2\6
${}\\{cout}\LL\.{"Did\ 10M\ solves\ in\ "}\LL\\{duration}(\,)\LL\.{"\ sum\ "}%
\LL\\{sum}\LL\\{endl}{}$;\par
\U23.\fi

\inx
\fin
\con
